<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sc√©nario ‚Äî √âtouffement</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    :root{
      --bgGlass: rgba(8,10,14,.66);
      --bgGlass2: rgba(8,10,14,.46);
      --stroke: rgba(255, 180, 120, .24);
      --stroke2: rgba(255,255,255,.10);

      --text: rgba(255,255,255,.93);
      --muted: rgba(255,255,255,.73);

      --ember: rgba(255,150,70,1);
      --ember2: rgba(255,120,50,1);
      --gold: rgba(255,200,80,1);
      --red: rgba(255,70,70,1);
      --green: rgba(45,200,120,1);
      --blue: rgba(80,170,255,1);
    }

    html, body{
      margin:0;
      background: transparent;
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .game{
      min-height: 100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 14px;
    }

    .panel{
      width: min(980px, 100%);
      border-radius: 18px;
      position: relative;
      overflow: hidden;
      background: linear-gradient(180deg, rgba(255,140,60,.11), rgba(0,0,0,.10));
    }
    .panel::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius: 18px;
      border: 1px solid rgba(255, 180, 120, .20);
      box-shadow:
        0 0 0 1px rgba(0,0,0,.34) inset,
        0 0 65px rgba(255,120,50,.10),
        0 24px 90px rgba(0,0,0,.52);
      pointer-events:none;
      z-index:0;
    }
    .panel::after{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(650px 240px at 70% 18%, rgba(255,150,70,.22), transparent 60%),
        radial-gradient(520px 260px at 18% 92%, rgba(255,90,50,.16), transparent 65%),
        radial-gradient(420px 180px at 50% 55%, rgba(80,170,255,.08), transparent 70%);
      pointer-events:none;
      z-index:0;
    }

    /* ========= HUD SEPARATION ========= */
    .hudWrap{
      padding: 14px 14px 0;
      position: relative;
      z-index: 2;
    }
    .hudContainer{
      background: rgba(0,0,0,.10);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 18px;
      padding: 12px;
      box-shadow: 0 16px 60px rgba(0,0,0,.35);
    }

    .topbar{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }

    .hudbox{
      background: var(--bgGlass);
      border: 1px solid var(--stroke);
      border-radius: 14px;
      padding: 12px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      backdrop-filter: blur(12px);
      box-shadow: 0 16px 50px rgba(0,0,0,.40);
      min-height: 90px;
      position: relative;
      overflow:hidden;
    }
    .hudbox::after{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(280px 120px at 20% 0%, rgba(255,150,70,.18), transparent 60%);
      pointer-events:none;
      opacity:.85;
    }

    .profile{
      display:flex;
      align-items:center;
      gap: 12px;
      min-width: 0;
      position: relative;
      z-index:2;
    }

    /* ‚úÖ Avatar portrait + zoom visage */
    .avatarFrame{
      width: 86px;
      height: 86px;
      border-radius: 22px;
      padding: 4px;
      background: linear-gradient(180deg, rgba(255,150,70,.35), rgba(80,170,255,.12));
      box-shadow: 0 14px 34px rgba(0,0,0,.45);
      flex: 0 0 auto;
    }
    .avatar{
      width: 100%;
      height: 100%;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      object-fit: cover;
      object-position: 50% 8%;   /* ‚úÖ zoom + focus visage (plus haut) */
      transform: scale(1.22);    /* ‚úÖ zoom suppl√©mentaire */
      transform-origin: 50% 15%;
    }

    .ptext{ min-width: 0; position: relative; z-index:2; }
    .pname{
      font-weight: 950;
      letter-spacing: .2px;
      font-size: 19px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      text-shadow: 0 14px 28px rgba(0,0,0,.58);
    }
    .prole{
      margin-top: 2px;
      color: var(--muted);
      font-size: 12px;
      font-weight: 850;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .chip{
      background: rgba(255,150,70,.14);
      border: 1px solid rgba(255,150,70,.20);
      color: rgba(255,255,255,.88);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      font-weight: 950;
      white-space: nowrap;
      position: relative;
      z-index:2;
    }

    .stats{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content:flex-end;
      position: relative;
      z-index:2;
    }

    .stat{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      font-size: 12px;
      font-weight: 950;
      white-space: nowrap;
    }

    /* Timer improved (ring + glow) */
    .timerWrap{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
    }
    .ring{
      width: 36px;
      height: 36px;
      border-radius: 999px;
      background:
        conic-gradient(var(--gold) var(--p, 0%), rgba(255,255,255,.12) 0);
      display:grid;
      place-items:center;
      box-shadow: 0 0 0 4px rgba(255,200,80,.14);
      transition: box-shadow .2s ease;
    }
    .ringInner{
      width: 26px;
      height: 26px;
      border-radius: 999px;
      background: rgba(0,0,0,.32);
      border: 1px solid rgba(255,255,255,.12);
    }
    .sec{
      font-weight: 950;
      font-size: 14px;
      letter-spacing: .2px;
    }
    .timerDanger .ring{
      background: conic-gradient(var(--red) var(--p, 0%), rgba(255,255,255,.12) 0);
      box-shadow: 0 0 0 4px rgba(255,70,70,.16), 0 0 30px rgba(255,70,70,.20);
    }
    .timerWarn .ring{
      background: conic-gradient(var(--gold) var(--p, 0%), rgba(255,255,255,.12) 0);
      box-shadow: 0 0 0 4px rgba(255,200,80,.16), 0 0 28px rgba(255,200,80,.14);
    }

    /* Stress */
    .stressWrap{
      width: 170px;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .stressBar{
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(45,200,120,.95), rgba(255,200,80,.95), rgba(255,70,70,.95));
      transition: width .25s ease;
    }

    /* ========= QUESTION CONTAINER (separate from HUD) ========= */
    .main{
      padding: 12px 14px 14px;
      position: relative;
      z-index: 2;
    }

    .questionContainer{
      margin-top: 12px;
      background: rgba(0,0,0,.10);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 18px;
      padding: 12px;
      box-shadow: 0 16px 60px rgba(0,0,0,.35);
    }

    .frame{
      background: var(--bgGlass2);
      border: 1px solid var(--stroke);
      border-radius: 16px;
      padding: 16px;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 60px rgba(0,0,0,.42);
      position: relative;
      overflow:hidden;
    }

    .frameGlow{
      position:absolute;
      inset:-2px;
      pointer-events:none;
      background:
        radial-gradient(720px 220px at 55% 0%, rgba(255,150,70,.18), transparent 60%),
        radial-gradient(700px 240px at 40% 120%, rgba(80,170,255,.10), transparent 60%);
      opacity:.9;
    }

    .qmeta{
      color: rgba(255,255,255,.70);
      font-size: 12px;
      font-weight: 950;
      letter-spacing: .35px;
      text-transform: uppercase;
    }
    .qtitle{
      margin-top: 4px;
      font-weight: 950;
      font-size: clamp(18px, 2.1vw, 24px);
      line-height: 1.2;
      text-shadow: 0 14px 28px rgba(0,0,0,.58);
    }
    .qdesc{
      margin-top: 8px;
      color: rgba(255,255,255,.80);
      font-size: 13px;
      line-height: 1.45;
      max-width: 920px;
    }

    .options{
      display:flex;
      flex-direction:column;
      gap: 10px;
      margin-top: 14px;
    }

    .opt{
      border-radius: 12px;
      padding: 12px 14px;
      font-weight: 950;
      letter-spacing: .2px;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, filter .12s ease, background .12s ease;
      border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(80,170,255,.22), rgba(80,170,255,.14));
    }
    .opt:hover{
      transform: translateY(-1px);
      filter: brightness(1.07);
      background: linear-gradient(180deg, rgba(255,150,70,.22), rgba(80,170,255,.10));
    }
    .opt:active{ transform: translateY(0px); filter: brightness(.98); }

    .opt.sel{
      background: linear-gradient(180deg, rgba(255,150,70,.30), rgba(255,120,50,.18));
      border-color: rgba(255,150,70,.30);
      box-shadow: 0 0 0 3px rgba(255,150,70,.10);
    }

    .actions{
      display:flex;
      gap: 10px;
      justify-content:flex-end;
      margin-top: 14px;
      flex-wrap: wrap;
    }

    .btnNeo{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.12);
      color: rgba(255,255,255,.88);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 950;
      letter-spacing: .2px;
    }

    .btnPrimary{
      border: none;
      background: linear-gradient(180deg, rgba(255,176,90,1), rgba(255,120,50,1));
      color: rgba(10,12,18,.96);
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 950;
      letter-spacing: .2px;
      display:none;
    }
    .btnPrimary.show{ display:inline-block; }

    /* Overlay feedback */
    .overlay{
      position: absolute;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 10;
      background: rgba(0,0,0,.44);
      backdrop-filter: blur(7px);
    }

    .modalBox{
      width: min(720px, 92%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(8,10,14,.80);
      box-shadow: 0 24px 90px rgba(0,0,0,.58);
      overflow:hidden;
      position: relative;
    }
    .modalBox::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(420px 180px at 30% 0%, rgba(255,150,70,.18), transparent 60%);
      pointer-events:none;
      opacity:.9;
    }

    .modalTop{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      position: relative;
      z-index:2;
    }
    .badgeState{
      font-weight: 950;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      white-space: nowrap;
    }
    .bGood{ border-color: rgba(45,200,120,.30); background: rgba(45,200,120,.12); }
    .bWarn{ border-color: rgba(255,200,80,.30); background: rgba(255,200,80,.12); }
    .bBad { border-color: rgba(255,70,70,.35); background: rgba(255,70,70,.12); }

    .modalBody{
      padding: 14px 16px;
      color: rgba(255,255,255,.92);
      line-height: 1.5;
      font-size: 14px;
      position: relative;
      z-index:2;
    }

    .modalActions{
      padding: 14px 16px;
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      justify-content:flex-end;
      gap: 10px;
      flex-wrap: wrap;
      position: relative;
      z-index:2;
    }

    /* motion */
    .shake{ animation: shake .24s linear 1; }
    @keyframes shake{
      0% { transform: translateX(0px); }
      20%{ transform: translateX(-6px); }
      40%{ transform: translateX(6px); }
      60%{ transform: translateX(-4px); }
      80%{ transform: translateX(4px); }
      100%{ transform: translateX(0px); }
    }
    .pulseGood{ animation: pulseGood .32s ease 1; }
    @keyframes pulseGood{
      from{ box-shadow: 0 0 0 0 rgba(45,200,120,.0); }
      50%{ box-shadow: 0 0 0 7px rgba(45,200,120,.18); }
      to{ box-shadow: 0 0 0 0 rgba(45,200,120,.0); }
    }
    .flashBad{ animation: flashBad .30s ease 1; }
    @keyframes flashBad{
      from{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
      50%{ box-shadow: 0 0 0 7px rgba(255,70,70,.22); }
      to{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
    }

    /* timeout alarm visual */
    .alarmGlow{
      animation: alarmGlow 1.2s ease-in-out infinite;
    }
    @keyframes alarmGlow{
      0%{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
      50%{ box-shadow: 0 0 0 6px rgba(255,70,70,.18); }
      100%{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
    }

    @media (max-width: 720px){
      .topbar{ grid-template-columns: 1fr; }
      .stats{ justify-content:flex-start; }
      .stressWrap{ width: 140px; }
      .avatarFrame{ width: 80px; height: 80px; }
    }
  </style>
</head>

<body>
<div class="game">
  <div class="panel" id="panel">

    <!-- HUD separated -->
    <div class="hudWrap">
      <div class="hudContainer">
        <div class="topbar">
          <div class="hudbox">
            <div class="profile">
              <div class="avatarFrame">
                <img class="avatar" id="hudAvatar" alt="Avatar">
              </div>
              <div class="ptext">
                <div class="pname" id="hudName">Joueur</div>
                <div class="prole" id="hudRole">R√¥le: ‚Äî</div>
              </div>
            </div>
            <div class="chip" id="difficultyChip">MODE: NORMAL</div>
          </div>

          <div class="hudbox">
            <div class="stats">
              <div class="stat">‚≠ê <span id="hudScore">0</span></div>
              <div class="stat">Q <span id="hudQnum">1</span>/<span id="hudQtotal">10</span></div>

              <div class="timerWrap" id="timerWrap">
                <div class="ring" id="ring"><div class="ringInner"></div></div>
                <div class="sec"><span id="hudTime">12</span>s</div>
              </div>

              <div class="stressWrap" title="Stress">
                <div class="stressBar" id="stressBar"></div>
              </div>
            </div>
          </div>
        </div>
      </div><!-- /hudContainer -->
    </div><!-- /hudWrap -->

    <!-- Questions separated -->
    <div class="main">
      <div class="questionContainer">
        <div class="frame" id="frame">
          <div class="frameGlow"></div>

          <div class="qmeta" id="qMeta">Sc√©nario 1 ‚Äî √âtouffement</div>
          <div class="qtitle" id="qTitle">‚Ä¶</div>
          <div class="qdesc" id="qDesc">‚Ä¶</div>

          <div class="options" id="options"></div>

          <div class="actions">
            <button class="btnNeo" id="submitBtn" style="display:none;">Valider</button>
            <button class="btnNeo" id="resetBtn" style="display:none;">R√©initialiser</button>
          </div>

          <!-- Feedback overlay -->
          <div class="overlay" id="overlay">
            <div class="modalBox" id="modalBox">
              <div class="modalTop">
                <div class="badgeState" id="badgeState">‚Äî</div>
                <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
                  Score: <span id="modalScore">0</span> ‚Ä¢ Stress: <span id="modalStress">0</span>%
                </div>
              </div>
              <div class="modalBody" id="modalText">‚Ä¶</div>
              <div class="modalActions">
                <button class="btnNeo" id="retryBtn">R√©essayer</button>
                <button class="btnPrimary" id="nextBtn">Suivant</button>
              </div>
            </div>
          </div>

        </div>
      </div><!-- /questionContainer -->
    </div><!-- /main -->

  </div>
</div>

<script>
/* ===== utilities ===== */
function escapeHtml(str){
  return String(str)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

/* ===== AUDIO (web audio) ===== */
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
function tone(freq, dur=0.08, type="sine", gain=0.05){
  ensureAudio();
  const t0 = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type; osc.frequency.value = freq;
  g.gain.value = gain;
  osc.connect(g); g.connect(audioCtx.destination);
  osc.start(t0); osc.stop(t0 + dur);
}
function sfxClick(){ tone(520,0.04,"triangle",0.035); }
function sfxCorrect(){ tone(660,0.07,"sine",0.06); setTimeout(()=>tone(880,0.08,"sine",0.06), 80); }
function sfxWrong(){ tone(220,0.10,"square",0.05); setTimeout(()=>tone(180,0.12,"square",0.05), 90); }
function sfxCritical(){ tone(140,0.14,"sawtooth",0.05); setTimeout(()=>tone(120,0.16,"sawtooth",0.05), 120); }

/* ‚úÖ Long alarm when time is up */
function sfxAlarmLong(){
  ensureAudio();
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = "sawtooth";
  osc.frequency.setValueAtTime(520, now);
  osc.frequency.linearRampToValueAtTime(380, now + 0.35);
  osc.frequency.linearRampToValueAtTime(520, now + 0.70);
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(0.06, now + 0.02);
  g.gain.exponentialRampToValueAtTime(0.001, now + 0.95);
  osc.connect(g); g.connect(audioCtx.destination);
  osc.start(now);
  osc.stop(now + 1.0);
}

window.addEventListener("pointerdown", ()=>ensureAudio(), { once:true });

/* ===== player context ===== */
const role = localStorage.getItem("role") || "infirmier";
const playerName = localStorage.getItem("playerName") || "Joueur";
const avatarFile = localStorage.getItem("avatar") || "medecin_f.png";
const difficulty = (localStorage.getItem("difficulty") || "normal").toLowerCase();

const roleLabelMap = { medecin:"M√©decin", infirmier:"Infirmier", pompier:"Pompier" };
document.getElementById("hudName").textContent = playerName;
document.getElementById("hudRole").textContent = "R√¥le: " + (roleLabelMap[role] || "‚Äî");
document.getElementById("hudAvatar").src = "assets/avatars/" + avatarFile;

const difficultyConfig = {
  easy:         { time: 15, stressTick: 2,  stressWrong: 4,  stressCritical: 14, scoreOk: 10 },
  normal:       { time: 12, stressTick: 2,  stressWrong: 6,  stressCritical: 18, scoreOk: 10 },
  intermediate: { time: 10, stressTick: 3,  stressWrong: 8,  stressCritical: 22, scoreOk: 10 },
  expert:       { time: 8,  stressTick: 4,  stressWrong: 10, stressCritical: 26, scoreOk: 10 }
};
const cfg = difficultyConfig[difficulty] || difficultyConfig.normal;
document.getElementById("difficultyChip").textContent = "MODE: " + difficulty.toUpperCase();

/* role modifiers */
const roleMods = {
  medecin:   { stressMul: 1.15, scoreMul: 1.00 },
  infirmier: { stressMul: 1.00, scoreMul: 1.00 },
  pompier:   { stressMul: 1.08, scoreMul: 1.00 }
};
const rm = roleMods[role] || roleMods.infirmier;
const roleStress = (v)=> Math.round(v * rm.stressMul);
const roleScore  = (v)=> Math.round(v * rm.scoreMul);

/* ===== score / stress ===== */
let score = parseInt(localStorage.getItem("score") || "0", 10);
let stress = parseInt(localStorage.getItem("stress") || "0", 10);
score = isNaN(score) ? 0 : score;
stress = isNaN(stress) ? 0 : stress;

function setScore(v){
  score = v;
  localStorage.setItem("score", String(score));
  document.getElementById("hudScore").textContent = String(score);
  document.getElementById("modalScore").textContent = String(score);
}
function addScore(d){ setScore(score + d); }

function setStress(v){
  stress = clamp(v, 0, 100);
  localStorage.setItem("stress", String(stress));
  document.getElementById("stressBar").style.width = stress + "%";
  document.getElementById("modalStress").textContent = String(stress);
}
function addStress(d){ setStress(stress + d); }

setScore(score);
setStress(stress);

/* ===== questions (same diversified set as before) ===== */
const TOTAL = 10;
document.getElementById("hudQtotal").textContent = String(TOTAL);

const questions = [
  { type:"single", title:"Reconna√Ætre l‚Äôobstruction s√©v√®re",
    desc:"La victime ne peut pas parler et sa toux est faible. Quelle conclusion ?",
    options:[
      {text:"Obstruction l√©g√®re (encourager la toux)", kind:"wrong", fb:"‚ùå Toux faible/inefficace + impossibilit√© de parler = obstruction s√©v√®re."},
      {text:"Obstruction s√©v√®re des voies a√©riennes", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Correct : obstruction s√©v√®re (√©touffement grave)."},
      {text:"Crise d‚Äôangoisse uniquement", kind:"wrong", fb:"‚ùå Les signes orientent d‚Äôabord vers l‚Äôobstruction."}
    ]
  },
  { type:"tf", title:"Toux efficace",
    desc:"Vrai ou faux : si la victime tousse fort et parle, on fait Heimlich imm√©diatement.",
    tf:{
      trueOpt: {kind:"wrong", fb:"‚ùå Faux : si la toux est efficace, on encourage la toux et on surveille."},
      falseOpt:{kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Vrai : on encourage la toux et on surveille."}
    }
  },
  { type:"single", title:"S√©quence recommand√©e (adulte conscient)",
    desc:"Obstruction s√©v√®re chez adulte conscient : que fais-tu ?",
    options:[
      {text:"5 claques dorsales puis 5 compressions abdominales (en cycles)", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Correct : alterner 5 claques + 5 compressions."},
      {text:"Uniquement compressions abdominales", kind:"partial", pts: roleScore(5), fb:"üü° Partiel : tu as saut√© les claques dorsales. L‚Äôalternance am√©liore l‚Äôefficacit√©."},
      {text:"Insufflations (bouche-√†-bouche) directement", kind:"wrong", fb:"‚ùå Non : priorit√© √† la d√©sobstruction chez une victime consciente."}
    ]
  },
  { type:"sequence", title:"Ordre des actions",
    desc:"Choisis l‚Äôordre logique des 3 actions (tape dans l‚Äôordre).",
    steps:[
      {id:"eval", label:"√âvaluer : parler / tousser / respirer"},
      {id:"act",  label:"Appliquer le geste adapt√© (claques/pressions)"},
      {id:"call", label:"Alerter / demander de l‚Äôaide"}
    ],
    okPts: roleScore(cfg.scoreOk),
    okFb:"‚úÖ Bon ordre : √©valuer ‚Üí agir ‚Üí alerter (et poursuivre les gestes si besoin).",
    badFb:"‚ùå L‚Äôordre est important : √©valuer d‚Äôabord, puis agir, alerter rapidement si s√©v√®re."
  },
  { type:"multi", title:"Signes d‚Äô√©touffement s√©v√®re",
    desc:"S√©lectionne TOUTES les r√©ponses correctes, puis clique Valider.",
    options:[
      {text:"Impossible de parler", correct:true},
      {text:"Toux inefficace / faible", correct:true},
      {text:"Respiration normale et confortable", correct:false},
      {text:"Mains √† la gorge / d√©tresse", correct:true}
    ],
    okPts: roleScore(cfg.scoreOk),
    okFb:"‚úÖ Exact : incapacit√© √† parler + toux inefficace + d√©tresse = s√©v√®re.",
    badFb:"‚ùå Revois : ‚Äúrespiration normale‚Äù n‚Äôest pas un signe de s√©v√®re."
  },
  { type:"single", title:"Position pour les claques dorsales",
    desc:"Pour des claques dorsales efficaces, la victime doit √™tre‚Ä¶",
    options:[
      {text:"Pench√©e en avant", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Oui : gravit√© + efficacit√©."},
      {text:"T√™te en arri√®re", kind:"wrong", fb:"‚ùå Non : cela ne favorise pas l‚Äôexpulsion."},
      {text:"Allong√©e sur le dos", kind:"wrong", fb:"‚ùå Non (sauf inconscience / RCP)."}
    ]
  },
  { type:"single", title:"Erreur critique",
    desc:"Quel geste est dangereux ?",
    options:[
      {text:"Balayage du doigt √† l‚Äôaveugle", kind:"critical", pts:-10, fb:"üö® ERREUR CRITIQUE : tu peux enfoncer l‚Äôobjet plus loin."},
      {text:"Retirer un objet clairement visible", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Oui, seulement si visible et accessible."},
      {text:"Encourager la toux si elle est efficace", kind:"ok", pts: roleScore(5), fb:"üü° Correct (si toux efficace)."}
    ]
  },
  { type:"single", title:"Femme enceinte / personne corpulente",
    desc:"Si les claques √©chouent, tu fais‚Ä¶",
    options:[
      {text:"Compressions thoraciques", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Correct : thoraciques √† la place des abdominales."},
      {text:"Compressions abdominales", kind:"critical", pts:-10, fb:"üö® ERREUR CRITIQUE : risque de blessure (grossesse)."},
      {text:"Donner de l‚Äôeau", kind:"wrong", fb:"‚ùå Non : risque d‚Äôinhalation."}
    ]
  },
  { type:"single", title:"Victime inconsciente",
    desc:"La victime perd connaissance. Que fais-tu en priorit√© ?",
    options:[
      {text:"Allonger au sol + RCP (compressions)", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Oui : inconsciente ‚Üí au sol, RCP si respiration anormale."},
      {text:"La relever et la faire marcher", kind:"critical", pts:-10, fb:"üö® ERREUR CRITIQUE : perte de temps vital."},
      {text:"Attendre sans rien faire", kind:"critical", pts:-10, fb:"üö® ERREUR CRITIQUE : inaction = risque vital."}
    ]
  },
  { type:"single", title:"Apr√®s expulsion de l‚Äôobjet",
    desc:"L‚Äôobjet sort, la victime respire mais tousse encore. Que fais-tu ?",
    options:[
      {text:"Surveiller + avis m√©dical si sympt√¥mes persistent", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Oui : surveillance et avis si douleur/toux persistante."},
      {text:"Je pars, tout est fini", kind:"partial", pts: roleScore(5), fb:"üü° Partiel : l‚Äôurgence est pass√©e, mais la surveillance reste importante."},
      {text:"Recommencer Heimlich ‚Äúpour √™tre s√ªr‚Äù", kind:"wrong", fb:"‚ùå Non : si respiration OK, on ne recommence pas."}
    ]
  },
];

/* ===== timer (ring progress) ===== */
let idx = 0;
let locked = false;
let timeLeft = cfg.time;
let timerId = null;

const hudQnum = document.getElementById("hudQnum");
const hudTime = document.getElementById("hudTime");
const ring = document.getElementById("ring");
const timerWrap = document.getElementById("timerWrap");

function setRingProgress(){
  const p = clamp(Math.round((timeLeft / cfg.time) * 100), 0, 100);
  ring.style.setProperty("--p", p + "%");
  timerWrap.classList.remove("timerWarn", "timerDanger");
  if(timeLeft <= 4) timerWrap.classList.add("timerDanger");
  else if(timeLeft <= 7) timerWrap.classList.add("timerWarn");
}

function startTimer(){
  clearInterval(timerId);
  timeLeft = cfg.time;
  hudTime.textContent = String(timeLeft);
  setRingProgress();

  timerId = setInterval(()=>{
    if(locked) return;
    timeLeft--;
    hudTime.textContent = String(timeLeft);
    setRingProgress();

    if(timeLeft <= 0){
      clearInterval(timerId);

      // ‚úÖ long alarm + visual alarm pulse
      sfxAlarmLong();
      timerWrap.classList.add("alarmGlow");
      setTimeout(()=>timerWrap.classList.remove("alarmGlow"), 1600);

      addStress(roleStress(cfg.stressTick));
      showOverlay("warn",
        "‚è±Ô∏è Temps √©coul√© ! Sous stress, tu peux commettre une erreur. Relis la situation et r√©essaie.",
        { allowRetry:true, allowNext:false }
      );
      motion("wrong");
    }
  }, 1000);
}

/* ===== render & interactions ===== */
const qTitle = document.getElementById("qTitle");
const qDesc  = document.getElementById("qDesc");
const optionsEl = document.getElementById("options");
const submitBtn = document.getElementById("submitBtn");
const resetBtn = document.getElementById("resetBtn");

const overlay = document.getElementById("overlay");
const badgeState = document.getElementById("badgeState");
const modalText = document.getElementById("modalText");
const retryBtn = document.getElementById("retryBtn");
const nextBtn = document.getElementById("nextBtn");
const frame = document.getElementById("frame");
const modalBox = document.getElementById("modalBox");

let multiSelected = new Set();
let seqOrder = [];

function clearActions(){
  submitBtn.style.display = "none";
  resetBtn.style.display = "none";
  submitBtn.onclick = null;
  resetBtn.onclick = null;
}

function setQuestion(i){
  locked = false;
  clearInterval(timerId);
  multiSelected.clear();
  seqOrder = [];
  clearActions();
  hideOverlay();

  const q = questions[i];
  hudQnum.textContent = String(i+1);

  qTitle.textContent = q.title;
  qDesc.innerHTML = q.desc;

  optionsEl.innerHTML = "";

  if(q.type === "single"){
    q.options.forEach(opt=>{
      const d = document.createElement("div");
      d.className = "opt";
      d.textContent = opt.text;
      d.onclick = ()=>{ sfxClick(); handleSingle(opt); };
      optionsEl.appendChild(d);
    });
  }
  else if(q.type === "tf"){
    const t = document.createElement("div");
    t.className = "opt"; t.textContent = "Vrai";
    t.onclick = ()=>{ sfxClick(); handleSingle(q.tf.trueOpt); };
    optionsEl.appendChild(t);

    const f = document.createElement("div");
    f.className = "opt"; f.textContent = "Faux";
    f.onclick = ()=>{ sfxClick(); handleSingle(q.tf.falseOpt); };
    optionsEl.appendChild(f);
  }
  else if(q.type === "multi"){
    q.options.forEach((opt, idxOpt)=>{
      const d = document.createElement("div");
      d.className = "opt"; d.textContent = opt.text;
      d.onclick = ()=>{
        sfxClick();
        if(multiSelected.has(idxOpt)){
          multiSelected.delete(idxOpt); d.classList.remove("sel");
        } else {
          multiSelected.add(idxOpt); d.classList.add("sel");
        }
      };
      optionsEl.appendChild(d);
    });

    submitBtn.style.display = "inline-block";
    resetBtn.style.display = "inline-block";
    submitBtn.textContent = "Valider";
    resetBtn.textContent = "R√©initialiser";

    submitBtn.onclick = ()=> handleMulti(q);
    resetBtn.onclick = ()=> {
      multiSelected.clear();
      [...optionsEl.children].forEach(ch=>ch.classList.remove("sel"));
    };
  }
  else if(q.type === "sequence"){
    q.steps.forEach(step=>{
      const d = document.createElement("div");
      d.className = "opt"; d.textContent = step.label;
      d.onclick = ()=>{
        sfxClick();
        if(seqOrder.includes(step.id)) return;
        seqOrder.push(step.id);
        d.classList.add("sel");
        d.textContent = `${seqOrder.length}. ${step.label}`;
      };
      optionsEl.appendChild(d);
    });

    submitBtn.style.display = "inline-block";
    resetBtn.style.display = "inline-block";
    submitBtn.textContent = "Valider";
    resetBtn.textContent = "R√©initialiser";

    submitBtn.onclick = ()=> handleSequence(q);
    resetBtn.onclick = ()=> setQuestion(i);
  }

  startTimer();
}

function handleSingle(opt){
  if(locked) return;
  locked = true;
  clearInterval(timerId);

  if(opt.kind === "ok"){
    addScore(opt.pts || roleScore(cfg.scoreOk));
    showOverlay("good", opt.fb || "‚úÖ Correct.", { allowRetry:false, allowNext:true });
    sfxCorrect();
    motion("good");
  } else if(opt.kind === "partial"){
    addScore(opt.pts || roleScore(5));
    addStress(roleStress(cfg.stressWrong));
    showOverlay("warn", opt.fb || "üü° Partiel. R√©essaye.", { allowRetry:true, allowNext:false });
    sfxWrong();
    motion("wrong");
  } else if(opt.kind === "critical"){
    addScore(opt.pts || -10);
    addStress(roleStress(cfg.stressCritical));
    showOverlay("bad", opt.fb || "üö® Erreur critique.", { allowRetry:true, allowNext:false });
    sfxCritical();
    motion("critical");
    try{ window.parent.postMessage({type:"CRITICAL_ERROR", q: idx+1}, "*"); }catch(e){}
  } else {
    addStress(roleStress(cfg.stressWrong));
    showOverlay("warn", opt.fb || "‚ùå Incorrect.", { allowRetry:true, allowNext:false });
    sfxWrong();
    motion("wrong");
  }
}

function handleMulti(q){
  if(locked) return;
  locked = true;
  clearInterval(timerId);

  const chosen = [...multiSelected].sort((a,b)=>a-b);
  const correctIdx = q.options.map((o,i)=>o.correct?i:null).filter(v=>v!==null);

  const ok = chosen.length === correctIdx.length && chosen.every((v,i)=>v===correctIdx[i]);

  if(ok){
    addScore(q.okPts || roleScore(cfg.scoreOk));
    showOverlay("good", q.okFb || "‚úÖ Correct.", { allowRetry:false, allowNext:true });
    sfxCorrect();
    motion("good");
  } else {
    addStress(roleStress(cfg.stressWrong));
    showOverlay("warn", q.badFb || "‚ùå Certaines r√©ponses sont incorrectes.", { allowRetry:true, allowNext:false });
    sfxWrong();
    motion("wrong");
  }
}

function handleSequence(q){
  if(locked) return;
  locked = true;
  clearInterval(timerId);

  const expected = ["eval","act","call"];
  const ok = seqOrder.length === 3 && expected.every((v,i)=>seqOrder[i]===v);

  if(ok){
    addScore(q.okPts || roleScore(cfg.scoreOk));
    showOverlay("good", q.okFb || "‚úÖ Correct.", { allowRetry:false, allowNext:true });
    sfxCorrect();
    motion("good");
  } else {
    addStress(roleStress(cfg.stressWrong));
    showOverlay("warn", q.badFb || "‚ùå Ordre incorrect.", { allowRetry:true, allowNext:false });
    sfxWrong();
    motion("wrong");
  }
}

/* ===== overlay ===== */
function showOverlay(kind, text, {allowRetry, allowNext}){
  badgeState.className = "badgeState";
  if(kind==="good"){ badgeState.classList.add("bGood"); badgeState.textContent="‚úÖ Bonne r√©ponse"; }
  if(kind==="warn"){ badgeState.classList.add("bWarn"); badgeState.textContent="‚ö†Ô∏è √Ä corriger"; }
  if(kind==="bad"){  badgeState.classList.add("bBad");  badgeState.textContent="üö® Erreur critique"; }

  modalText.textContent = text;
  overlay.style.display = "flex";

  retryBtn.style.display = allowRetry ? "inline-block" : "none";
  nextBtn.classList.toggle("show", !!allowNext);
  nextBtn.style.display = allowNext ? "inline-block" : "none";

  retryBtn.onclick = ()=>{ hideOverlay(); setQuestion(idx); };
  nextBtn.onclick  = ()=>{
    hideOverlay();
    idx++;
    if(idx < TOTAL) setQuestion(idx);
    else endScenario();
  };
}
function hideOverlay(){ overlay.style.display = "none"; }

/* ===== motion ===== */
function motion(type){
  frame.classList.remove("shake","pulseGood","flashBad");
  modalBox.classList.remove("shake","pulseGood","flashBad");

  if(type==="good"){
    frame.classList.add("pulseGood");
  } else if(type==="wrong"){
    modalBox.classList.add("shake");
  } else if(type==="critical"){
    modalBox.classList.add("shake");
    frame.classList.add("flashBad");
  }
}

/* ===== end ===== */
function endScenario(){
  clearInterval(timerId);
  hideOverlay();
  optionsEl.innerHTML = "";
  submitBtn.style.display = "none";
  resetBtn.style.display = "none";

  const result = score >= 80 ? "üü¢ Intervention ma√Ætris√©e"
               : score >= 60 ? "üü° Bon niveau ‚Äî √† renforcer"
               : "üî¥ R√©visions conseill√©es";

  qTitle.textContent = "Fin du sc√©nario ‚Äî √âtouffement";
  qDesc.innerHTML = `
    <div style="margin-top:8px; color: rgba(255,255,255,.86);">
      <div style="font-weight:950; font-size:16px;">R√©sultat : ${escapeHtml(result)}</div>
      <div style="margin-top:6px;">‚≠ê Score final : <b>${score}</b></div>
      <div>üò∞ Stress : <b>${stress}%</b></div>
      <div style="margin-top:10px; color: rgba(255,255,255,.75); font-size:13px;">
        Tu peux maintenant cliquer sur <b>Suivant</b> dans Genially pour continuer.
      </div>
    </div>
  `;
  document.getElementById("qMeta").textContent = "Debrief";
}

/* ===== init ===== */
localStorage.setItem("playerName", playerName);
localStorage.setItem("role", role);
localStorage.setItem("avatar", avatarFile);

setQuestion(0);
</script>

</body>
</html>
