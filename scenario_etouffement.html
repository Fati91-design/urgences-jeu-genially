<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sc√©nario ‚Äî √âtouffement</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root{
      --glass: rgba(25, 27, 31, .72);
      --glass2: rgba(15, 17, 20, .55);
      --stroke: rgba(255, 200, 150, .22);
      --strokeW: rgba(255,255,255,.10);
      --text: rgba(255,255,255,.93);
      --muted: rgba(255,255,255,.70);
      --ember: rgba(255,150,70,1);
      --ember2: rgba(255,120,50,1);
      --gold: rgba(255,200,80,1);
      --red: rgba(255,70,70,1);
      --green: rgba(45,200,120,1);
      --blue: rgba(80,170,255,1);
    }
    html,body{
      margin:0;
      background: transparent;
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    /* ‚úÖ plus de "grand conteneur" : on garde juste une sc√®ne propre */
    .stage{
      min-height: 100vh;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding: 18px;
    }
    .wrap{
      width: min(1120px, 100%);
    }
    /* ===== HUD (deux blocs s√©par√©s, sans grand conteneur) ===== */
    .hud{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
      margin-bottom: 18px;
    }

    .hudbox{
      background: var(--glass);
      border: 1px solid var(--stroke);
      border-radius: 18px;
      padding: 14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 14px;
      position: relative;
      overflow:hidden;
      box-shadow: 0 18px 65px rgba(0,0,0,.45);
      backdrop-filter: blur(12px);
    }

    .hudbox::after{
      content:"";
      position:absolute;
      inset:-2px;
      pointer-events:none;
      background:
        radial-gradient(420px 160px at 15% 0%, rgba(255,150,70,.18), transparent 60%),
        radial-gradient(520px 220px at 85% 120%, rgba(80,170,255,.10), transparent 60%);
      opacity:.9;
    }

    /* LEFT HUD: avatar + nom */
    .profile{
      display:flex;
      align-items:center;
      gap: 14px;
      min-width: 0;
      position: relative;
      z-index:2;
    }

    .avatarFrame{
      width: 92px;
      height: 92px;
      border-radius: 24px;
      padding: 4px;
      background: linear-gradient(180deg, rgba(255,150,70,.36), rgba(80,170,255,.14));
      box-shadow: 0 18px 42px rgba(0,0,0,.45);
      flex: 0 0 auto;
    }

    .avatar{
      width:100%;
      height:100%;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.12);
      object-fit: cover;

      /* ‚úÖ zoom + focus visage */
      object-position: 50% 6%;
      transform: scale(1.35);
      transform-origin: 50% 12%;
      background: rgba(255,255,255,.06);
    }

    .ptext{ min-width:0; }
    .pname{
      font-weight: 950;
      font-size: 22px;
      line-height: 1.05;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      text-shadow: 0 14px 30px rgba(0,0,0,.55);
    }
    .prole{
      margin-top: 4px;
      font-weight: 850;
      font-size: 13px;
      color: var(--muted);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .chip{
      background: rgba(255,150,70,.14);
      border: 1px solid rgba(255,150,70,.20);
      border-radius: 999px;
      padding: 9px 12px;
      font-size: 12px;
      font-weight: 950;
      white-space: nowrap;
      position: relative;
      z-index:2;
    }

    /* RIGHT HUD: score + Q + timer + stress */
    .stats{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 12px;
      flex-wrap: wrap;
      position: relative;
      z-index:2;
    }

    .pill{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      font-weight: 950;
      font-size: 13px;
      white-space: nowrap;
    }

    /* ‚úÖ Timer plus attractif */
    .timerPill{
      padding: 8px 10px;
      gap: 10px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }

    .ring{
      width: 40px;
      height: 40px;
      border-radius: 999px;
      background: conic-gradient(var(--gold) var(--p, 0%), rgba(255,255,255,.14) 0);
      display:grid;
      place-items:center;
      box-shadow: 0 0 0 5px rgba(255,200,80,.14), 0 0 28px rgba(255,200,80,.10);
      transition: box-shadow .2s ease;
    }
    .ringInner{
      width: 28px;
      height: 28px;
      border-radius: 999px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      display:grid;
      place-items:center;
      color: rgba(255,255,255,.9);
      font-size: 14px;
      font-weight: 950;
    }

    .timeText{
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .timeText .label{
      font-size: 12px;
      font-weight: 900;
      color: rgba(255,255,255,.75);
      letter-spacing: .2px;
    }
    .timeText .sec{
      font-size: 16px;
      font-weight: 950;
    }

    .timerWarn .ring{
      background: conic-gradient(var(--gold) var(--p, 0%), rgba(255,255,255,.14) 0);
      box-shadow: 0 0 0 5px rgba(255,200,80,.18), 0 0 32px rgba(255,200,80,.14);
    }
    .timerDanger .ring{
      background: conic-gradient(var(--red) var(--p, 0%), rgba(255,255,255,.14) 0);
      box-shadow: 0 0 0 5px rgba(255,70,70,.20), 0 0 40px rgba(255,70,70,.18);
    }

    .stressWrap{
      width: 240px;
      height: 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .stressBar{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(45,200,120,.95), rgba(255,200,80,.95), rgba(255,70,70,.95));
      transition: width .25s ease;
    }

    /* ===== Question container (sans wrapper g√©ant) ===== */
    .frame{
      background: var(--glass2);
      border: 1px solid var(--stroke);
      border-radius: 18px;
      padding: 18px;
      position: relative;
      overflow:hidden;
      box-shadow: 0 18px 70px rgba(0,0,0,.50);
      backdrop-filter: blur(12px);
    }

    .frame::after{
      content:"";
      position:absolute;
      inset:-2px;
      pointer-events:none;
      background:
        radial-gradient(800px 260px at 55% 0%, rgba(255,150,70,.16), transparent 60%),
        radial-gradient(760px 260px at 40% 120%, rgba(80,170,255,.10), transparent 60%);
      opacity:.9;
    }

    .qmeta{
      position: relative;
      z-index:2;
      color: rgba(255,255,255,.70);
      font-size: 12px;
      font-weight: 950;
      letter-spacing: .35px;
      text-transform: uppercase;
    }

    .qtitle{
      position: relative;
      z-index:2;
      margin-top: 6px;
      font-weight: 950;
      font-size: clamp(18px, 2.2vw, 26px);
      line-height: 1.2;
      text-shadow: 0 14px 30px rgba(0,0,0,.55);
    }

    .qdesc{
      position: relative;
      z-index:2;
      margin-top: 10px;
      color: rgba(255,255,255,.82);
      font-size: 14px;
      line-height: 1.5;
      max-width: 980px;
    }

    .options{
      position: relative;
      z-index:2;
      display:flex;
      flex-direction:column;
      gap: 12px;
      margin-top: 16px;
    }

    .opt{
      border-radius: 14px;
      padding: 13px 14px;
      font-weight: 950;
      letter-spacing: .2px;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, filter .12s ease, background .12s ease;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(80,170,255,.22), rgba(80,170,255,.14));
      box-shadow: 0 10px 28px rgba(0,0,0,.20);
    }
    .opt:hover{
      transform: translateY(-1px);
      filter: brightness(1.07);
      background: linear-gradient(180deg, rgba(255,150,70,.22), rgba(80,170,255,.10));
    }
    .opt:active{ transform: translateY(0px); filter: brightness(.98); }

    .opt.sel{
      background: linear-gradient(180deg, rgba(255,150,70,.30), rgba(255,120,50,.18));
      border-color: rgba(255,150,70,.30);
      box-shadow: 0 0 0 3px rgba(255,150,70,.10), 0 16px 34px rgba(0,0,0,.28);
    }

    .actions{
      position: relative;
      z-index:2;
      display:flex;
      justify-content:flex-end;
      gap: 10px;
      margin-top: 16px;
      flex-wrap: wrap;
    }

    .btnNeo{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.90);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 950;
      letter-spacing: .2px;
    }

    .btnPrimary{
      border: none;
      background: linear-gradient(180deg, rgba(255,176,90,1), rgba(255,120,50,1));
      color: rgba(10,12,18,.96);
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 950;
      letter-spacing: .2px;
      display:none;
    }
    .btnPrimary.show{ display:inline-block; }

    /* ===== Overlays ===== */
    .overlay{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 50;
      background: rgba(0,0,0,.48);
      backdrop-filter: blur(8px);
    }

    .modalBox{
      width: min(760px, 92%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(8,10,14,.82);
      box-shadow: 0 26px 90px rgba(0,0,0,.62);
      overflow:hidden;
      position: relative;
    }

    .modalTop{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }

    .badgeState{
      font-weight: 950;
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      white-space: nowrap;
    }
    .bGood{ border-color: rgba(45,200,120,.30); background: rgba(45,200,120,.12); }
    .bWarn{ border-color: rgba(255,200,80,.30); background: rgba(255,200,80,.12); }
    .bBad { border-color: rgba(255,70,70,.35); background: rgba(255,70,70,.12); }

    .modalBody{
      padding: 16px;
      color: rgba(255,255,255,.92);
      line-height: 1.5;
      font-size: 14px;
    }

    .modalActions{
      padding: 14px 16px;
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      justify-content:flex-end;
      gap: 10px;
      flex-wrap: wrap;
    }

    /* ‚úÖ Start overlay (Pr√™t ?) */
    .startTitle{
      font-weight: 950;
      font-size: 22px;
      margin-bottom: 6px;
    }
    .startText{
      color: rgba(255,255,255,.82);
      font-size: 14px;
      line-height: 1.45;
    }
    .startBtn{
      border:none;
      border-radius: 14px;
      padding: 12px 16px;
      font-weight: 950;
      letter-spacing: .3px;
      background: linear-gradient(180deg, rgba(255,176,90,1), rgba(255,120,50,1));
      color: rgba(10,12,18,.96);
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
    }

    /* Motion */
    .shake{ animation: shake .24s linear 1; }
    @keyframes shake{
      0% { transform: translateX(0px); }
      20%{ transform: translateX(-6px); }
      40%{ transform: translateX(6px); }
      60%{ transform: translateX(-4px); }
      80%{ transform: translateX(4px); }
      100%{ transform: translateX(0px); }
    }

    .pulseGood{ animation: pulseGood .32s ease 1; }
    @keyframes pulseGood{
      from{ box-shadow: 0 0 0 0 rgba(45,200,120,.0); }
      50%{ box-shadow: 0 0 0 7px rgba(45,200,120,.18); }
      to{ box-shadow: 0 0 0 0 rgba(45,200,120,.0); }
    }

    .flashBad{ animation: flashBad .30s ease 1; }
    @keyframes flashBad{
      from{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
      50%{ box-shadow: 0 0 0 7px rgba(255,70,70,.22); }
      to{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
    }

    /* Alarm visual */
    .alarmGlow{ animation: alarmGlow 1.2s ease-in-out infinite; }
    @keyframes alarmGlow{
      0%{ transform: scale(1); }
      50%{ transform: scale(1.02); }
      100%{ transform: scale(1); }
    }

    @media (max-width: 860px){
      .hud{ grid-template-columns: 1fr; }
      .stressWrap{ width: 190px; }
    }
  </style>
</head>

<body>
<div class="stage">
  <div class="wrap">

    <!-- HUD -->
    <div class="hud">
      <!-- Left: profile -->
      <div class="hudbox">
        <div class="profile">
          <div class="avatarFrame">
            <img class="avatar" id="hudAvatar" alt="Avatar">
          </div>
          <div class="ptext">
            <div class="pname" id="hudName">Joueur</div>
            <div class="prole" id="hudRole">R√¥le: ‚Äî</div>
          </div>
        </div>
        <div class="chip" id="difficultyChip">MODE: NORMAL</div>
      </div>

      <!-- Right: stats -->
      <div class="hudbox">
        <div class="stats">
          <div class="pill">‚≠ê <span id="hudScore">0</span></div>
          <div class="pill">Q <span id="hudQnum">1</span>/<span id="hudQtotal">10</span></div>

          <div class="pill timerPill" id="timerPill">
            <div class="ring" id="ring"><div class="ringInner">‚è±</div></div>
            <div class="timeText">
              <div class="label">Temps</div>
              <div class="sec"><span id="hudTime">12</span>s</div>
            </div>
          </div>

          <div class="stressWrap" title="Stress">
            <div class="stressBar" id="stressBar"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Questions -->
    <div class="frame" id="frame">
      <div class="qmeta" id="qMeta">Sc√©nario 1 ‚Äî √âtouffement</div>
      <div class="qtitle" id="qTitle">‚Ä¶</div>
      <div class="qdesc" id="qDesc">‚Ä¶</div>

      <div class="options" id="options"></div>

      <div class="actions">
        <button class="btnNeo" id="submitBtn" style="display:none;">Valider</button>
        <button class="btnNeo" id="resetBtn" style="display:none;">R√©initialiser</button>
      </div>
    </div>

  </div>
</div>

<!-- START overlay -->
<div class="overlay" id="startOverlay" style="display:flex;">
  <div class="modalBox">
    <div class="modalTop">
      <div class="badgeState bWarn">üéÆ Pr√™t ?</div>
      <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
        Sc√©nario 1 ‚Ä¢ √âtouffement
      </div>
    </div>
    <div class="modalBody">
      <div class="startTitle">Tu vas intervenir en situation r√©elle.</div>
      <div class="startText">
        Tu as peu de temps pour d√©cider. Lis bien, choisis vite, et √©vite les erreurs critiques.
        <br><br>
        <b>Es-tu pr√™t √† commencer ?</b>
      </div>
    </div>
    <div class="modalActions">
      <button class="startBtn" id="startBtn">D√âMARRER</button>
    </div>
  </div>
</div>

<!-- Feedback overlay -->
<div class="overlay" id="overlay">
  <div class="modalBox" id="modalBox">
    <div class="modalTop">
      <div class="badgeState" id="badgeState">‚Äî</div>
      <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
        Score: <span id="modalScore">0</span> ‚Ä¢ Stress: <span id="modalStress">0</span>%
      </div>
    </div>
    <div class="modalBody" id="modalText">‚Ä¶</div>
    <div class="modalActions">
      <button class="btnNeo" id="retryBtn">R√©essayer</button>
      <button class="btnPrimary" id="nextBtn">Suivant</button>
    </div>
  </div>
</div>

<script>
/* =========================
   AUDIO (WebAudio)
========================= */
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }

function tone(freq, dur=0.08, type="sine", gain=0.05){
  ensureAudio();
  const t0 = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type; osc.frequency.value = freq;
  g.gain.value = gain;
  osc.connect(g); g.connect(audioCtx.destination);
  osc.start(t0); osc.stop(t0 + dur);
}

function sfxClick(){ tone(520,0.04,"triangle",0.035); }
function sfxCorrect(){ tone(660,0.07,"sine",0.06); setTimeout(()=>tone(880,0.08,"sine",0.06), 80); }
function sfxWrong(){ tone(220,0.10,"square",0.05); setTimeout(()=>tone(180,0.12,"square",0.05), 90); }
function sfxCritical(){ tone(140,0.14,"sawtooth",0.05); setTimeout(()=>tone(120,0.16,"sawtooth",0.05), 120); }

/* ‚úÖ Alarme plus longue quand temps = 0 */
function sfxAlarmLong(){
  ensureAudio();
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();

  osc.type = "sawtooth";
  osc.frequency.setValueAtTime(520, now);
  osc.frequency.linearRampToValueAtTime(380, now + 0.35);
  osc.frequency.linearRampToValueAtTime(520, now + 0.70);

  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(0.07, now + 0.02);
  g.gain.exponentialRampToValueAtTime(0.001, now + 1.10);

  osc.connect(g); g.connect(audioCtx.destination);
  osc.start(now);
  osc.stop(now + 1.2);
}

/* =========================
   CONTEXTE JOUEUR
========================= */
const role = localStorage.getItem("role") || "infirmier";
const playerName = localStorage.getItem("playerName") || "Joueur";
const avatarFile = localStorage.getItem("avatar") || "medecin_f.png";
const difficulty = (localStorage.getItem("difficulty") || "normal").toLowerCase();

const roleLabelMap = { medecin:"M√©decin", infirmier:"Infirmier", pompier:"Pompier" };
document.getElementById("hudName").textContent = playerName;
document.getElementById("hudRole").textContent = "R√¥le: " + (roleLabelMap[role] || "‚Äî");
document.getElementById("hudAvatar").src = "assets/avatars/" + avatarFile;

const difficultyConfig = {
  easy:         { time: 15, stressTick: 2,  stressWrong: 4,  stressCritical: 14, scoreOk: 10 },
  normal:       { time: 12, stressTick: 2,  stressWrong: 6,  stressCritical: 18, scoreOk: 10 },
  intermediate: { time: 10, stressTick: 3,  stressWrong: 8,  stressCritical: 22, scoreOk: 10 },
  expert:       { time: 8,  stressTick: 4,  stressWrong: 10, stressCritical: 26, scoreOk: 10 }
};
const cfg = difficultyConfig[difficulty] || difficultyConfig.normal;
document.getElementById("difficultyChip").textContent = "MODE: " + difficulty.toUpperCase();

/* Role modifier */
const roleMods = {
  medecin:   { stressMul: 1.15, scoreMul: 1.00 },
  infirmier: { stressMul: 1.00, scoreMul: 1.00 },
  pompier:   { stressMul: 1.08, scoreMul: 1.00 }
};
const rm = roleMods[role] || roleMods.infirmier;
const roleStress = (v)=> Math.round(v * rm.stressMul);
const roleScore  = (v)=> Math.round(v * rm.scoreMul);

/* =========================
   SCORE / STRESS
========================= */
let score = parseInt(localStorage.getItem("score") || "0", 10);
let stress = parseInt(localStorage.getItem("stress") || "0", 10);
score = isNaN(score) ? 0 : score;
stress = isNaN(stress) ? 0 : stress;

function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

function setScore(v){
  score = v;
  localStorage.setItem("score", String(score));
  document.getElementById("hudScore").textContent = String(score);
  document.getElementById("modalScore").textContent = String(score);
}
function addScore(d){ setScore(score + d); }

function setStress(v){
  stress = clamp(v, 0, 100);
  localStorage.setItem("stress", String(stress));
  document.getElementById("stressBar").style.width = stress + "%";
  document.getElementById("modalStress").textContent = String(stress);
}
function addStress(d){ setStress(stress + d); }

setScore(score);
setStress(stress);

/* =========================
   QUESTIONS (diversifi√©es)
========================= */
const TOTAL = 10;
document.getElementById("hudQtotal").textContent = String(TOTAL);

const questions = [
  {
    type:"single",
    title:"Reconna√Ætre l‚Äôobstruction s√©v√®re",
    desc:"La victime ne peut pas parler et sa toux est faible. Quelle conclusion ?",
    options:[
      {text:"Obstruction l√©g√®re (encourager la toux)", kind:"wrong", fb:"‚ùå Toux faible/inefficace + impossibilit√© de parler = obstruction s√©v√®re."},
      {text:"Obstruction s√©v√®re des voies a√©riennes", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Correct : obstruction s√©v√®re (√©touffement grave)."},
      {text:"Crise d‚Äôangoisse uniquement", kind:"wrong", fb:"‚ùå Les signes orientent d‚Äôabord vers l‚Äôobstruction."}
    ]
  },
  {
    type:"tf",
    title:"Toux efficace",
    desc:"Vrai ou faux : si la victime tousse fort et parle, on fait Heimlich imm√©diatement.",
    tf:{
      trueOpt: {kind:"wrong", fb:"‚ùå Faux : si la toux est efficace, on encourage la toux et on surveille."},
      falseOpt:{kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Vrai : on encourage la toux et on surveille."}
    }
  },
  {
    type:"single",
    title:"S√©quence recommand√©e (adulte conscient)",
    desc:"Obstruction s√©v√®re chez adulte conscient : que fais-tu ?",
    options:[
      {text:"5 claques dorsales puis 5 compressions abdominales (en cycles)", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Correct : alterner 5 claques + 5 compressions."},
      {text:"Uniquement compressions abdominales", kind:"partial", pts: roleScore(5), fb:"üü° Partiel : tu as saut√© les claques dorsales. L‚Äôalternance am√©liore l‚Äôefficacit√©."},
      {text:"Insufflations (bouche-√†-bouche) directement", kind:"wrong", fb:"‚ùå Non : priorit√© √† la d√©sobstruction chez une victime consciente."}
    ]
  },
  {
    type:"sequence",
    title:"Ordre des actions",
    desc:"Choisis l‚Äôordre logique des 3 actions (tape dans l‚Äôordre).",
    steps:[
      {id:"eval", label:"√âvaluer : parler / tousser / respirer"},
      {id:"act",  label:"Appliquer le geste adapt√© (claques/pressions)"},
      {id:"call", label:"Alerter / demander de l‚Äôaide"}
    ],
    okPts: roleScore(cfg.scoreOk),
    okFb:"‚úÖ Bon ordre : √©valuer ‚Üí agir ‚Üí alerter (et poursuivre les gestes si besoin).",
    badFb:"‚ùå L‚Äôordre est important : √©valuer d‚Äôabord, puis agir, alerter rapidement si s√©v√®re."
  },
  {
    type:"multi",
    title:"Signes d‚Äô√©touffement s√©v√®re",
    desc:"S√©lectionne TOUTES les r√©ponses correctes, puis clique Valider.",
    options:[
      {text:"Impossible de parler", correct:true},
      {text:"Toux inefficace / faible", correct:true},
      {text:"Respiration normale et confortable", correct:false},
      {text:"Mains √† la gorge / d√©tresse", correct:true}
    ],
    okPts: roleScore(cfg.scoreOk),
    okFb:"‚úÖ Exact : incapacit√© √† parler + toux inefficace + d√©tresse = s√©v√®re.",
    badFb:"‚ùå Revois : ‚Äúrespiration normale‚Äù n‚Äôest pas un signe de s√©v√®re."
  },
  {
    type:"single",
    title:"Position pour les claques dorsales",
    desc:"Pour des claques dorsales efficaces, la victime doit √™tre‚Ä¶",
    options:[
      {text:"Pench√©e en avant", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Oui : gravit√© + efficacit√©."},
      {text:"T√™te en arri√®re", kind:"wrong", fb:"‚ùå Non : cela ne favorise pas l‚Äôexpulsion."},
      {text:"Allong√©e sur le dos", kind:"wrong", fb:"‚ùå Non (sauf inconscience / RCP)."}
    ]
  },
  {
    type:"single",
    title:"Erreur critique",
    desc:"Quel geste est dangereux ?",
    options:[
      {text:"Balayage du doigt √† l‚Äôaveugle", kind:"critical", pts:-10, fb:"üö® ERREUR CRITIQUE : tu peux enfoncer l‚Äôobjet plus loin."},
      {text:"Retirer un objet clairement visible", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Oui, seulement si visible et accessible."},
      {text:"Encourager la toux si elle est efficace", kind:"ok", pts: roleScore(5), fb:"üü° Correct (si toux efficace)."}
    ]
  },
  {
    type:"single",
    title:"Femme enceinte / personne corpulente",
    desc:"Si les claques √©chouent, tu fais‚Ä¶",
    options:[
      {text:"Compressions thoraciques", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Correct : thoraciques √† la place des abdominales."},
      {text:"Compressions abdominales", kind:"critical", pts:-10, fb:"üö® ERREUR CRITIQUE : risque de blessure (grossesse)."},
      {text:"Donner de l‚Äôeau", kind:"wrong", fb:"‚ùå Non : risque d‚Äôinhalation."}
    ]
  },
  {
    type:"single",
    title:"Victime inconsciente",
    desc:"La victime perd connaissance. Que fais-tu en priorit√© ?",
    options:[
      {text:"Allonger au sol + RCP (compressions)", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Oui : inconsciente ‚Üí au sol, RCP si respiration anormale."},
      {text:"La relever et la faire marcher", kind:"critical", pts:-10, fb:"üö® ERREUR CRITIQUE : perte de temps vital."},
      {text:"Attendre sans rien faire", kind:"critical", pts:-10, fb:"üö® ERREUR CRITIQUE : inaction = risque vital."}
    ]
  },
  {
    type:"single",
    title:"Apr√®s expulsion de l‚Äôobjet",
    desc:"L‚Äôobjet sort, la victime respire mais tousse encore. Que fais-tu ?",
    options:[
      {text:"Surveiller + avis m√©dical si sympt√¥mes persistent", kind:"ok", pts: roleScore(cfg.scoreOk), fb:"‚úÖ Oui : surveillance et avis si douleur/toux persistante."},
      {text:"Je pars, tout est fini", kind:"partial", pts: roleScore(5), fb:"üü° Partiel : l‚Äôurgence est pass√©e, mais la surveillance reste importante."},
      {text:"Recommencer Heimlich ‚Äúpour √™tre s√ªr‚Äù", kind:"wrong", fb:"‚ùå Non : si respiration OK, on ne recommence pas."}
    ]
  }
];

/* =========================
   TIMER + UI
========================= */
let idx = 0;
let locked = true;          // ‚úÖ bloqu√© tant que pas d√©marr√©
let timeLeft = cfg.time;
let timerId = null;

const hudQnum = document.getElementById("hudQnum");
const hudTime = document.getElementById("hudTime");
const ring = document.getElementById("ring");
const timerPill = document.getElementById("timerPill");

function setRingProgress(){
  const p = clamp(Math.round((timeLeft / cfg.time) * 100), 0, 100);
  ring.style.setProperty("--p", p + "%");

  timerPill.classList.remove("timerWarn","timerDanger","alarmGlow");
  if(timeLeft <= 4) timerPill.classList.add("timerDanger");
  else if(timeLeft <= 7) timerPill.classList.add("timerWarn");
}

function startTimer(){
  clearInterval(timerId);
  timeLeft = cfg.time;
  hudTime.textContent = String(timeLeft);
  setRingProgress();

  timerId = setInterval(()=>{
    if(locked) return;
    timeLeft--;
    hudTime.textContent = String(timeLeft);
    setRingProgress();

    if(timeLeft <= 0){
      clearInterval(timerId);

      // ‚úÖ alarme longue + effet
      sfxAlarmLong();
      timerPill.classList.add("alarmGlow");

      addStress(roleStress(cfg.stressTick));
      showOverlay("warn",
        "‚è±Ô∏è Temps √©coul√© ! Sous stress, tu peux commettre une erreur. Relis la situation et r√©essaie.",
        { allowRetry:true, allowNext:false }
      );
      motion("wrong");
    }
  }, 1000);
}

/* =========================
   RENDER QUESTIONS
========================= */
const qTitle = document.getElementById("qTitle");
const qDesc  = document.getElementById("qDesc");
const optionsEl = document.getElementById("options");
const submitBtn = document.getElementById("submitBtn");
const resetBtn = document.getElementById("resetBtn");

const overlay = document.getElementById("overlay");
const badgeState = document.getElementById("badgeState");
const modalText = document.getElementById("modalText");
const retryBtn = document.getElementById("retryBtn");
const nextBtn = document.getElementById("nextBtn");
const frame = document.getElementById("frame");
const modalBox = document.getElementById("modalBox");

let multiSelected = new Set();
let seqOrder = [];

function clearActions(){
  submitBtn.style.display = "none";
  resetBtn.style.display = "none";
  submitBtn.onclick = null;
  resetBtn.onclick = null;
}

function setQuestion(i){
  locked = false;
  clearInterval(timerId);
  multiSelected.clear();
  seqOrder = [];
  clearActions();
  hideOverlay();

  const q = questions[i];
  hudQnum.textContent = String(i+1);

  qTitle.textContent = q.title;
  qDesc.innerHTML = q.desc;

  optionsEl.innerHTML = "";

  if(q.type === "single"){
    q.options.forEach(opt=>{
      const d = document.createElement("div");
      d.className = "opt";
      d.textContent = opt.text;
      d.onclick = ()=>{ sfxClick(); handleSingle(opt); };
      optionsEl.appendChild(d);
    });
  }
  else if(q.type === "tf"){
    const t = document.createElement("div");
    t.className = "opt"; t.textContent = "Vrai";
    t.onclick = ()=>{ sfxClick(); handleSingle(q.tf.trueOpt); };
    optionsEl.appendChild(t);

    const f = document.createElement("div");
    f.className = "opt"; f.textContent = "Faux";
    f.onclick = ()=>{ sfxClick(); handleSingle(q.tf.falseOpt); };
    optionsEl.appendChild(f);
  }
  else if(q.type === "multi"){
    q.options.forEach((opt, idxOpt)=>{
      const d = document.createElement("div");
      d.className = "opt"; d.textContent = opt.text;
      d.onclick = ()=>{
        sfxClick();
        if(multiSelected.has(idxOpt)){
          multiSelected.delete(idxOpt); d.classList.remove("sel");
        } else {
          multiSelected.add(idxOpt); d.classList.add("sel");
        }
      };
      optionsEl.appendChild(d);
    });

    submitBtn.style.display = "inline-block";
    resetBtn.style.display = "inline-block";
    submitBtn.textContent = "Valider";
    resetBtn.textContent = "R√©initialiser";

    submitBtn.onclick = ()=> handleMulti(q);
    resetBtn.onclick = ()=> {
      multiSelected.clear();
      [...optionsEl.children].forEach(ch=>ch.classList.remove("sel"));
    };
  }
  else if(q.type === "sequence"){
    q.steps.forEach(step=>{
      const d = document.createElement("div");
      d.className = "opt"; d.textContent = step.label;
      d.onclick = ()=>{
        sfxClick();
        if(seqOrder.includes(step.id)) return;
        seqOrder.push(step.id);
        d.classList.add("sel");
        d.textContent = `${seqOrder.length}. ${step.label}`;
      };
      optionsEl.appendChild(d);
    });

    submitBtn.style.display = "inline-block";
    resetBtn.style.display = "inline-block";
    submitBtn.textContent = "Valider";
    resetBtn.textContent = "R√©initialiser";

    submitBtn.onclick = ()=> handleSequence(q);
    resetBtn.onclick = ()=> setQuestion(i);
  }

  startTimer();
}

/* =========================
   LOGIQUE REPONSES
========================= */
function handleSingle(opt){
  if(locked) return;
  locked = true;
  clearInterval(timerId);

  if(opt.kind === "ok"){
    addScore(opt.pts || roleScore(cfg.scoreOk));
    showOverlay("good", opt.fb || "‚úÖ Correct.", { allowRetry:false, allowNext:true });
    sfxCorrect();
    motion("good");
  } else if(opt.kind === "partial"){
    addScore(opt.pts || roleScore(5));
    addStress(roleStress(cfg.stressWrong));
    showOverlay("warn", opt.fb || "üü° Partiel. R√©essaye.", { allowRetry:true, allowNext:false });
    sfxWrong();
    motion("wrong");
  } else if(opt.kind === "critical"){
    addScore(opt.pts || -10);
    addStress(roleStress(cfg.stressCritical));
    showOverlay("bad", opt.fb || "üö® Erreur critique.", { allowRetry:true, allowNext:false });
    sfxCritical();
    motion("critical");
    try{ window.parent.postMessage({type:"CRITICAL_ERROR", q: idx+1}, "*"); }catch(e){}
  } else {
    addStress(roleStress(cfg.stressWrong));
    showOverlay("warn", opt.fb || "‚ùå Incorrect.", { allowRetry:true, allowNext:false });
    sfxWrong();
    motion("wrong");
  }
}

function handleMulti(q){
  if(locked) return;
  locked = true;
  clearInterval(timerId);

  const chosen = [...multiSelected].sort((a,b)=>a-b);
  const correctIdx = q.options.map((o,i)=>o.correct?i:null).filter(v=>v!==null);
  const ok = chosen.length === correctIdx.length && chosen.every((v,i)=>v===correctIdx[i]);

  if(ok){
    addScore(q.okPts || roleScore(cfg.scoreOk));
    showOverlay("good", q.okFb || "‚úÖ Correct.", { allowRetry:false, allowNext:true });
    sfxCorrect();
    motion("good");
  } else {
    addStress(roleStress(cfg.stressWrong));
    showOverlay("warn", q.badFb || "‚ùå Certaines r√©ponses sont incorrectes.", { allowRetry:true, allowNext:false });
    sfxWrong();
    motion("wrong");
  }
}

function handleSequence(q){
  if(locked) return;
  locked = true;
  clearInterval(timerId);

  const expected = ["eval","act","call"];
  const ok = seqOrder.length === 3 && expected.every((v,i)=>seqOrder[i]===v);

  if(ok){
    addScore(q.okPts || roleScore(cfg.scoreOk));
    showOverlay("good", q.okFb || "‚úÖ Correct.", { allowRetry:false, allowNext:true });
    sfxCorrect();
    motion("good");
  } else {
    addStress(roleStress(cfg.stressWrong));
    showOverlay("warn", q.badFb || "‚ùå Ordre incorrect.", { allowRetry:true, allowNext:false });
    sfxWrong();
    motion("wrong");
  }
}

/* =========================
   OVERLAY FEEDBACK
========================= */
function showOverlay(kind, text, {allowRetry, allowNext}){
  badgeState.className = "badgeState";
  if(kind==="good"){ badgeState.classList.add("bGood"); badgeState.textContent="‚úÖ Bonne r√©ponse"; }
  if(kind==="warn"){ badgeState.classList.add("bWarn"); badgeState.textContent="‚ö†Ô∏è √Ä corriger"; }
  if(kind==="bad"){  badgeState.classList.add("bBad");  badgeState.textContent="üö® Erreur critique"; }

  modalText.textContent = text;
  overlay.style.display = "flex";

  retryBtn.style.display = allowRetry ? "inline-block" : "none";
  nextBtn.classList.toggle("show", !!allowNext);
  nextBtn.style.display = allowNext ? "inline-block" : "none";

  retryBtn.onclick = ()=>{
    hideOverlay();
    setQuestion(idx);
  };

  nextBtn.onclick = ()=>{
    hideOverlay();
    idx++;
    if(idx < TOTAL) setQuestion(idx);
    else endScenario();
  };
}

function hideOverlay(){ overlay.style.display = "none"; }

/* =========================
   MOTIONS
========================= */
function motion(type){
  frame.classList.remove("shake","pulseGood","flashBad");
  modalBox.classList.remove("shake","pulseGood","flashBad");

  if(type==="good"){
    frame.classList.add("pulseGood");
  } else if(type==="wrong"){
    modalBox.classList.add("shake");
  } else if(type==="critical"){
    modalBox.classList.add("shake");
    frame.classList.add("flashBad");
  }
}

/* =========================
   END
========================= */
function escapeHtml(str){
  return String(str).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}

function endScenario(){
  clearInterval(timerId);
  hideOverlay();
  optionsEl.innerHTML = "";
  submitBtn.style.display = "none";
  resetBtn.style.display = "none";

  const result = score >= 80 ? "üü¢ Intervention ma√Ætris√©e"
               : score >= 60 ? "üü° Bon niveau ‚Äî √† renforcer"
               : "üî¥ R√©visions conseill√©es";

  document.getElementById("qMeta").textContent = "Debrief";
  qTitle.textContent = "Fin du sc√©nario ‚Äî √âtouffement";
  qDesc.innerHTML = `
    <div style="margin-top:8px; color: rgba(255,255,255,.86);">
      <div style="font-weight:950; font-size:16px;">R√©sultat : ${escapeHtml(result)}</div>
      <div style="margin-top:6px;">‚≠ê Score final : <b>${score}</b></div>
      <div>üò∞ Stress : <b>${stress}%</b></div>
      <div style="margin-top:10px; color: rgba(255,255,255,.75); font-size:13px;">
        Tu peux maintenant cliquer sur <b>Suivant</b> dans Genially pour continuer.
      </div>
    </div>
  `;
}

/* =========================
   START BUTTON
========================= */
const startOverlay = document.getElementById("startOverlay");
const startBtn = document.getElementById("startBtn");

startBtn.addEventListener("click", ()=>{
  ensureAudio();          // active audio
  sfxClick();
  startOverlay.style.display = "none";
  idx = 0;
  setQuestion(0);
});

/* Init: afficher la premi√®re question visuellement mais sans interactions avant start */
(function initPreview(){
  locked = true;
  // on met du contenu placeholder sympa
  document.getElementById("qTitle").textContent = "Pr√©pare-toi‚Ä¶";
  document.getElementById("qDesc").innerHTML = "Clique sur <b>D√âMARRER</b> pour lancer le sc√©nario (le timer commencera).";
  document.getElementById("options").innerHTML = "";
  document.getElementById("hudQnum").textContent = "1";
  document.getElementById("hudTime").textContent = String(cfg.time);
  ring.style.setProperty("--p", "100%");
})();
</script>

</body>
</html>
