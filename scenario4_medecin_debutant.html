<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sc√©nario 4 ‚Äî Accident de la voie publique ‚Äî M√©decin</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    :root{
      --glass: rgba(25, 27, 31, .72);
      --glass2: rgba(15, 17, 20, .55);

      --text: rgba(255,255,255,.93);
      --muted: rgba(255,255,255,.70);

      --gold: rgba(255,200,80,1);
      --red: rgba(255,70,70,1);
      --green: rgba(45,200,120,1);
      --blue: rgba(80,170,255,1);
      --ember: rgba(255,150,70,1);
      --ember2: rgba(255,120,50,1);
    }

    html,body{
      margin:0;
      background: transparent;
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden; /* ‚úÖ Genially anti-scroll */
    }

    /* ====== GENIALLY STAGE ====== */
    .stage{
      height: 100vh;
      padding: 10px;
      overflow:hidden;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    .wrap{
      width: min(1120px, 100%);
      height: 100%;
      display:flex;
      flex-direction:column;
      gap: 12px;
      min-height:0;
    }

    /* ====== TOP TABS ====== */
    .topTabs{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .levelTab{
      display:flex; align-items:center; gap:10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: var(--glass);
      border: 1px solid rgba(255, 200, 150, .22);
      box-shadow: 0 12px 40px rgba(0,0,0,.38);
      backdrop-filter: blur(12px);
      font-weight: 950;
      letter-spacing: .2px;
    }
    .levelDot{
      width: 12px; height: 12px; border-radius: 999px;
      background: linear-gradient(180deg, rgba(255,200,80,1), rgba(255,120,50,1));
      box-shadow: 0 0 0 5px rgba(255,200,80,.14);
    }
    .progressShell{
      flex: 1;
      min-width: 220px;
      height: 9px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .progressBar{
      height:100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(255,200,80,1), rgba(255,120,50,1));
      box-shadow: 0 10px 28px rgba(0,0,0,.18);
      transition: width .25s ease;
    }
    .miniHint{
      display:flex; align-items:center; gap:10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      font-weight: 950;
      font-size: 12px;
      color: rgba(255,255,255,.80);
      white-space: nowrap;
    }

    /* ====== HUD ====== */
    .hud{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .hudbox{
      background: var(--glass);
      border: 1px solid rgba(255, 200, 150, .22);
      border-radius: 18px;
      padding: 14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 14px;
      position: relative;
      overflow:hidden;
      box-shadow: 0 18px 65px rgba(0,0,0,.45);
      backdrop-filter: blur(12px);
      min-height: 96px;
    }
    .hudbox::after{
      content:"";
      position:absolute; inset:-2px;
      pointer-events:none;
      background:
        radial-gradient(420px 160px at 15% 0%, rgba(255,150,70,.18), transparent 60%),
        radial-gradient(520px 220px at 85% 120%, rgba(80,170,255,.10), transparent 60%);
      opacity:.9;
    }

    .profile{
      display:flex; align-items:center; gap: 14px;
      min-width: 0;
      position: relative; z-index:2;
    }
    .avatarFrame{
      width: 72px; height: 72px; border-radius: 22px; padding: 4px;
      background: linear-gradient(180deg, rgba(255,150,70,.36), rgba(80,170,255,.14));
      box-shadow: 0 18px 42px rgba(0,0,0,.45);
      flex: 0 0 auto;
    }
    .avatar{
      width:100%; height:100%;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      object-fit: cover;
      object-position: 50% 6%;
      transform: scale(1.25);
      transform-origin: 50% 12%;
      background: rgba(255,255,255,.06);
    }
    .ptext{ min-width:0; }
    .pname{
      font-weight: 950; font-size: 18px; line-height: 1.05;
      white-space: nowrap; overflow:hidden; text-overflow: ellipsis;
      text-shadow: 0 14px 30px rgba(0,0,0,.55);
    }
    .prole{
      margin-top: 4px;
      font-weight: 850; font-size: 12px;
      color: var(--muted);
      white-space: nowrap; overflow:hidden; text-overflow: ellipsis;
    }
    .chip{
      background: rgba(255,150,70,.14);
      border: 1px solid rgba(255,150,70,.20);
      border-radius: 999px;
      padding: 9px 12px;
      font-size: 12px;
      font-weight: 950;
      white-space: nowrap;
      position: relative; z-index:2;
    }

    .stats{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 10px;
      flex-wrap: wrap;
      position: relative; z-index:2;
    }
    .pill{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 9px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      font-weight: 950;
      font-size: 12px;
      white-space: nowrap;
    }
    .timerPill{
      padding: 7px 9px; gap: 10px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }
    .ring{
      width: 34px; height: 34px; border-radius: 999px;
      background: conic-gradient(var(--gold) var(--p, 0%), rgba(255,255,255,.14) 0);
      display:grid; place-items:center;
      box-shadow: 0 0 0 5px rgba(255,200,80,.14), 0 0 28px rgba(255,200,80,.10);
      transition: box-shadow .2s ease;
    }
    .ringInner{
      width: 24px; height: 24px; border-radius: 999px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      display:grid; place-items:center;
      color: rgba(255,255,255,.9);
      font-size: 12px; font-weight: 950;
    }
    .timeText{ display:flex; align-items:center; gap: 8px; }
    .timeText .label{ font-size: 11px; font-weight: 900; color: rgba(255,255,255,.75); }
    .timeText .sec{ font-size: 14px; font-weight: 950; }

    .timerWarn .ring{
      background: conic-gradient(var(--gold) var(--p, 0%), rgba(255,255,255,.14) 0);
      box-shadow: 0 0 0 5px rgba(255,200,80,.18), 0 0 32px rgba(255,200,80,.14);
    }
    .timerDanger .ring{
      background: conic-gradient(var(--red) var(--p, 0%), rgba(255,255,255,.14) 0);
      box-shadow: 0 0 0 5px rgba(255,70,70,.20), 0 0 40px rgba(255,70,70,.18);
    }

    .stressWrap{
      width: 200px; height: 10px; border-radius: 999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .stressBar{
      height:100%; width:0%;
      background: linear-gradient(90deg, rgba(45,200,120,.95), rgba(255,200,80,.95), rgba(255,70,70,.95));
      transition: width .25s ease;
    }

    /* ====== FRAME QUIZ ====== */

    .frame{
      flex: 1;
      min-height: 0;
      background: var(--glass2);
      border: 1px solid rgba(255, 200, 150, .22);
      border-radius: 18px;
      padding: 16px;
      position: relative;
      overflow:hidden;
      box-shadow: 0 18px 70px rgba(0,0,0,.50);
      backdrop-filter: blur(12px);
      display:flex;
      flex-direction:column;
      gap: 10px;
	    display:flex;
  flex-direction:column;
  height: calc(100vh - 18px - 18px - 18px - 220px); 
  /* ‚Üë ajuste selon ton HUD (voir notes) */
  min-height: 520px;
    }
    .frame::after{
      content:"";
      position:absolute; inset:-2px; pointer-events:none;
      background:
        radial-gradient(800px 260px at 55% 0%, rgba(255,150,70,.16), transparent 60%),
        radial-gradient(760px 260px at 40% 120%, rgba(80,170,255,.10), transparent 60%);
      opacity:.9;
    }

    .qmeta{ position: relative; z-index:2; color: rgba(255,255,255,.70); font-size: 12px; font-weight: 950; letter-spacing: .35px; text-transform: uppercase; }
    .qtitle{ position: relative; z-index:2; margin-top: 2px; font-weight: 950; font-size: clamp(18px, 2.2vw, 24px); line-height: 1.2; text-shadow: 0 14px 30px rgba(0,0,0,.55); }
    .qdesc{ position: relative; z-index:2; margin-top: 4px; color: rgba(255,255,255,.82); font-size: 13px; line-height: 1.5; max-width: 980px; }

    .options{
      position: relative; z-index:2;
      display:flex; flex-direction:column;
      gap: 12px;
      margin-top: 6px;
      overflow:auto;
      padding-right: 6px;
      min-height: 0;
	  flex: 1;
    }

    /* scrollbar */
    .options::-webkit-scrollbar{ width: 10px; }
    .options::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.16); border-radius: 999px; }
    .options::-webkit-scrollbar-track{ background: rgba(0,0,0,.10); border-radius: 999px; }

    .opt{
      border-radius: 14px;
      padding: 13px 14px;
      font-weight: 950;
      letter-spacing: .2px;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, filter .12s ease, background .12s ease;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(80,170,255,.22), rgba(80,170,255,.14));
      box-shadow: 0 10px 28px rgba(0,0,0,.20);
    }
    .opt:hover{ transform: translateY(-1px); filter: brightness(1.07); background: linear-gradient(180deg, rgba(255,150,70,.22), rgba(80,170,255,.10)); }
    .opt:active{ transform: translateY(0px); filter: brightness(.98); }

    .opt.sel{
      background: linear-gradient(180deg, rgba(255,150,70,.30), rgba(255,120,50,.18));
      border-color: rgba(255,150,70,.30);
      box-shadow: 0 0 0 3px rgba(255,150,70,.10), 0 16px 34px rgba(0,0,0,.28);
    }

    .actions{
      position: sticky;
      display:flex;
      justify-content:space-between;
      gap: 10px;
      margin-top: 14px;
      flex-wrap: wrap;
      align-items:center;
	  padding-top: 12px;
	  margin-top: 14px;
      bottom: 0;
    }

    .actionsLeft, .actionsRight{
      display:flex; gap: 10px; flex-wrap: wrap; align-items:center;
    }

    .btnNeo{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.90);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 950;
      letter-spacing: .2px;
    }
    .btnNeo:disabled{
      opacity:.45;
      cursor:not-allowed;
    }

    .btnPrimary{
      border: none;
      background: linear-gradient(180deg, rgba(255,176,90,1), rgba(255,120,50,1));
      color: rgba(10,12,18,.96);
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 950;
      letter-spacing: .2px;
    }
    .btnPrimary:disabled{
      opacity:.45;
      filter: grayscale(.2);
      cursor: not-allowed;
    }

    /* ====== OVERLAYS ====== */
    .overlay{
      position: fixed; inset: 0;
      display:none; align-items:center; justify-content:center;
      z-index: 50;
      background: rgba(0,0,0,.48);
      backdrop-filter: blur(8px);
    }
    .modalBox{
      width: min(780px, 92%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(8,10,14,.82);
      box-shadow: 0 26px 90px rgba(0,0,0,.62);
      overflow:hidden;
      position: relative;
    }
    .modalTop{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
    }
    .badgeState{
      font-weight: 950;
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      white-space: nowrap;
    }
    .bGood{ border-color: rgba(45,200,120,.30); background: rgba(45,200,120,.12); }
    .bWarn{ border-color: rgba(255,200,80,.30); background: rgba(255,200,80,.12); }
    .bBad { border-color: rgba(255,70,70,.35); background: rgba(255,70,70,.12); }

    .modalBody{ padding: 16px; color: rgba(255,255,255,.92); line-height: 1.5; font-size: 14px; }
    .modalActions{
      padding: 14px 16px;
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex; justify-content:flex-end; gap: 10px; flex-wrap: wrap;
    }

    .startTitle{ font-weight: 950; font-size: 22px; margin-bottom: 6px; }
    .startText{ color: rgba(255,255,255,.82); font-size: 14px; line-height: 1.45; }
    .startBtn{
      border:none; border-radius: 14px; padding: 12px 16px;
      font-weight: 950; letter-spacing: .3px;
      background: linear-gradient(180deg, rgba(255,176,90,1), rgba(255,120,50,1));
      color: rgba(10,12,18,.96);
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
    }

    /* Anim */
    .shake{ animation: shake .24s linear 1; }
    @keyframes shake{
      0% { transform: translateX(0px); }
      20%{ transform: translateX(-6px); }
      40%{ transform: translateX(6px); }
      60%{ transform: translateX(-4px); }
      80%{ transform: translateX(4px); }
      100%{ transform: translateX(0px); }
    }
    .pulseGood{ animation: pulseGood .32s ease 1; }
    @keyframes pulseGood{
      from{ box-shadow: 0 0 0 0 rgba(45,200,120,.0); }
      50%{ box-shadow: 0 0 0 7px rgba(45,200,120,.18); }
      to{ box-shadow: 0 0 0 0 rgba(45,200,120,.0); }
    }
    .flashBad{ animation: flashBad .30s ease 1; }
    @keyframes flashBad{
      from{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
      50%{ box-shadow: 0 0 0 7px rgba(255,70,70,.22); }
      to{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
    }

    @media (max-width: 860px){
      .hud{ grid-template-columns: 1fr; }
      .progressShell{ min-width: 100%; }
      .stressWrap{ width: 170px; }
    }

    /* Hotspot */
    @keyframes hsPulse {
      0% { box-shadow: 0 0 0 0 rgba(255,255,255,.25); border-color: rgba(255,255,255,.55); }
      70% { box-shadow: 0 0 0 14px rgba(255,255,255,0); border-color: rgba(255,255,255,.85); }
      100% { box-shadow: 0 0 0 0 rgba(255,255,255,0); border-color: rgba(255,255,255,.55); }
    }
    .hotspot-zone{
      position:absolute;
      background: transparent !important;
      border: 2px solid rgba(255,255,255,.65);
      border-radius: 16px;
      padding:0;
      margin:0;
      cursor:pointer;
      animation: hsPulse 1.35s infinite;
    }
    .hotspot-zone.sel{
      border-color: rgba(34,197,94,.95);
      box-shadow: 0 0 0 6px rgba(34,197,94,.20);
      animation: none;
    }

    /* image_single */
    .imgGrid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:16px;
      margin-top: 6px;
    }
    @media (max-width: 900px){
      .imgGrid{ grid-template-columns: 1fr; }
    }
    .imgCard{
      border-radius:18px;
      overflow:hidden;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      cursor:pointer;
      transition:.15s ease;
      box-shadow:0 14px 30px rgba(0,0,0,.25);
    }
    .imgCard:hover{ transform:translateY(-3px); filter:brightness(1.05); }
    .imgCard.sel{
      outline:3px solid rgba(255,165,0,.4);
      box-shadow:0 0 0 4px rgba(255,165,0,.25), 0 20px 40px rgba(0,0,0,.35);
    }
    .imgHead{
      padding:12px 16px;
      font-weight:900;
      display:flex;
      justify-content:space-between;
      background:linear-gradient(180deg, rgba(120,180,255,.25), rgba(120,180,255,.10));
    }
    .imgTag{
      width:36px;
      height:36px;
      border-radius:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      background:rgba(0,0,0,.25);
    }
    .imgPic{
      width:100%;
      height: 220px;
      object-fit:cover;
      display:block;
    }
    .imgCap{
      padding:14px;
      text-align:center;
      font-weight:800;
    }

    /* Key overlay table */
    .keyClose{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      border-radius: 12px;
      padding: 8px 10px;
      font-weight: 950;
      cursor:pointer;
    }
  </style>
</head>

<body>
<div class="stage">
  <div class="wrap">

    <!-- TOP TABS -->
    <div class="topTabs">
      <div class="levelTab">
        <span class="levelDot"></span>
        <span id="levelTabText">D√âBUTANT</span>
      </div>

      <div class="progressShell" aria-label="progression">
        <div class="progressBar" id="progressBar"></div>
      </div>

      <div class="miniHint" id="miniHint">
        ‚è± <span id="miniTime">60s</span> ‚Ä¢ üéØ <span id="miniAttempts">3</span> ‚Ä¢ üí° <span id="miniHints">3</span>
      </div>
    </div>

    <!-- HUD -->
    <div class="hud">
      <div class="hudbox">
        <div class="profile">
          <div class="avatarFrame">
            <img class="avatar" id="hudAvatar" alt="Avatar">
          </div>
          <div class="ptext">
            <div class="pname" id="hudName">Dr. Joueur</div>
            <div class="prole" id="hudRole">R√¥le: ‚Äî</div>
          </div>
        </div>
        <div class="chip" id="difficultyChip">MODE: D√âBUTANT</div>
      </div>

      <div class="hudbox">
        <div class="stats">
          <div class="pill">‚≠ê <span id="hudScore">0</span></div>
          <div class="pill">Q <span id="hudQnum">1</span>/<span id="hudQtotal">20</span></div>
          <div class="pill">üéØ Tentatives <span id="hudAttempts">1</span>/<span id="hudAttemptsMax">3</span></div>

          <div class="pill timerPill" id="timerPill">
            <div class="ring" id="ring"><div class="ringInner">‚è±</div></div>
            <div class="timeText">
              <div class="label">Temps</div>
              <div class="sec"><span id="hudTime">60</span>s</div>
            </div>
          </div>

          <div class="stressWrap" title="Stress">
            <div class="stressBar" id="stressBar"></div>
          </div>

          <button class="btnNeo" id="hintBtn" type="button">üí° Indice (<span id="hintsLeftText">3</span>)</button>
          <button class="btnNeo" id="pauseBtn" type="button">‚è∏ Pause</button>
        </div>
      </div>
    </div>

    <!-- FRAME -->
    <div class="frame" id="frame">
      <div class="qmeta" id="qMeta">Sc√©nario 4 ‚Äî Accident de la voie publique</div>
      <div class="qtitle" id="qTitle">‚Ä¶</div>
      <div class="qdesc" id="qDesc">‚Ä¶</div>

      <div class="options" id="options"></div>

      <div class="actions">
        <div class="actionsLeft">
          <button class="btnNeo" id="showKeyBtn" type="button" disabled>üìò Corrig√©</button>
          <button class="btnPrimary" id="endBtn" type="button" style="display:none;">‚úÖ Terminer</button>
        </div>
        <div class="actionsRight">
          <button class="btnPrimary" id="validateBtn" type="button" disabled>Valider</button>
          <button class="btnNeo" id="clearBtn" type="button" style="display:none;">Effacer</button>
        </div>
      </div>
    </div>

  </div>
</div>

<!-- START overlay -->
<div class="overlay" id="startOverlay" style="display:flex;">
  <div class="modalBox">
    <div class="modalTop">
      <div class="badgeState bWarn">üéÆ Pr√™t ?</div>
      <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
        Mission ‚Ä¢ Accident de la voie publique
      </div>
    </div>
    <div class="modalBody">
      <div class="startTitle">Tu as une mission.</div>
      <div class="startText" id="startRules">
        ‚Ä¶
      </div>
    </div>
    <div class="modalActions">
      <button class="startBtn" id="startBtn">D√âMARRER</button>
    </div>
  </div>
</div>

<!-- FEEDBACK overlay -->
<div class="overlay" id="overlay">
  <div class="modalBox" id="modalBox">
    <div class="modalTop">
      <div class="badgeState" id="badgeState">‚Äî</div>
      <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
        Score: <span id="modalScore">0</span> ‚Ä¢ Stress: <span id="modalStress">0</span>%
      </div>
    </div>
    <div class="modalBody" id="modalText">‚Ä¶</div>
    <div class="modalActions">
      <button class="btnNeo" id="retryBtn">R√©essayer</button>
      <button class="btnPrimary" id="nextBtn">Suivant</button>
      <button class="btnPrimary" id="okBtn" style="display:none;">OK</button>
    </div>
  </div>
</div>

<!-- HINT overlay -->
<div class="overlay" id="hintOverlay">
  <div class="modalBox">
    <div class="modalTop">
      <div class="badgeState bWarn">üí° Indice</div>
      <div style="display:flex; gap:10px; align-items:center;">
        <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
          Indices restants : <span id="hintOverlayLeft">3</span>
        </div>
        <button class="keyClose" id="hintCloseBtn">X</button>
      </div>
    </div>
    <div class="modalBody" id="hintText">‚Ä¶</div>
    <div class="modalActions">
      <button class="btnPrimary" id="hintOkBtn">OK</button>
    </div>
  </div>
</div>

<!-- KEY overlay -->
<div class="overlay" id="keyOverlay">
  <div class="modalBox">
    <div class="modalTop">
      <div class="badgeState bGood">üìò Corrig√©</div>
      <button class="keyClose" id="keyCloseBtn">X</button>
    </div>
    <div class="modalBody" id="keyBody">
      ‚Ä¶
    </div>
    <div class="modalActions">
      <button class="btnPrimary" id="keyOkBtn">Fermer</button>
    </div>
  </div>
</div>

<script>
/* ========= SFX (WebAudio) ========= */
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
function tone(freq, dur=0.08, type="sine", gain=0.05){
  ensureAudio();
  const t0 = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type; osc.frequency.value = freq;
  g.gain.value = gain;
  osc.connect(g); g.connect(audioCtx.destination);
  osc.start(t0); osc.stop(t0 + dur);
}
function sfxClick(){ tone(520,0.04,"triangle",0.035); }
function sfxCorrect(){ tone(660,0.07,"sine",0.06); setTimeout(()=>tone(880,0.08,"sine",0.06), 80); }
function sfxWrong(){ tone(220,0.10,"square",0.05); setTimeout(()=>tone(180,0.12,"square",0.05), 90); }
function sfxCritical(){ tone(140,0.14,"sawtooth",0.05); setTimeout(()=>tone(120,0.16,"sawtooth",0.05), 120); }
function sfxAlarmLong(){
  ensureAudio();
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = "sawtooth";
  osc.frequency.setValueAtTime(520, now);
  osc.frequency.linearRampToValueAtTime(380, now + 0.35);
  osc.frequency.linearRampToValueAtTime(520, now + 0.70);
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(0.07, now + 0.02);
  g.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
  osc.connect(g); g.connect(audioCtx.destination);
  osc.start(now); osc.stop(now + 1.25);
}
function sfxVictory(){
  const notes = [
    {f:659,d:0.10},{f:784,d:0.10},{f:988,d:0.14},
    {f:1175,d:0.18},{f:988,d:0.14},{f:1047,d:0.22}
  ];
  let t = 0;
  notes.forEach((n)=>{
    setTimeout(()=>tone(n.f, n.d, "sine", 0.065), t*1000);
    t += n.d + 0.03;
  });
}

/* ========= HELPERS ========= */
const el = (id)=>document.getElementById(id);
const clamp = (n,a,b)=> Math.max(a, Math.min(b,n));
const escapeHtml = (str)=> String(str)
  .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");

/* ========= DOM ========= */
const levelTabText = el("levelTabText");
const progressBar = el("progressBar");
const miniTime = el("miniTime");
const miniAttempts = el("miniAttempts");
const miniHints = el("miniHints");

const hudName = el("hudName");
const hudRole = el("hudRole");
const hudAvatar = el("hudAvatar");
const difficultyChip = el("difficultyChip");

const hudScore = el("hudScore");
const hudQnum = el("hudQnum");
const hudQtotal = el("hudQtotal");
const hudAttempts = el("hudAttempts");
const hudAttemptsMax = el("hudAttemptsMax");

const hudTime = el("hudTime");
const ring = el("ring");
const timerPill = el("timerPill");
const stressBar = el("stressBar");

const hintsLeftText = el("hintsLeftText");
const hintBtn = el("hintBtn");
const pauseBtn = el("pauseBtn");

const qMeta = el("qMeta");
const qTitle = el("qTitle");
const qDesc  = el("qDesc");
const optionsEl = el("options");

const validateBtn = el("validateBtn");
const clearBtn = el("clearBtn");
const showKeyBtn = el("showKeyBtn");
const endBtn = el("endBtn");

const startOverlay = el("startOverlay");
const startBtn = el("startBtn");
const startRules = el("startRules");

const overlay = el("overlay");
const modalBox = el("modalBox");
const badgeState = el("badgeState");
const modalText = el("modalText");
const modalScore = el("modalScore");
const modalStress = el("modalStress");
const retryBtn = el("retryBtn");
const nextBtn = el("nextBtn");
const okBtn = el("okBtn");

const hintOverlay = el("hintOverlay");
const hintOverlayLeft = el("hintOverlayLeft");
const hintText = el("hintText");
const hintOkBtn = el("hintOkBtn");
const hintCloseBtn = el("hintCloseBtn");

const keyOverlay = el("keyOverlay");
const keyBody = el("keyBody");
const keyCloseBtn = el("keyCloseBtn");
const keyOkBtn = el("keyOkBtn");

const frame = el("frame");

/* ========= CONFIG ========= */
const SCENARIO = {
  id: 4,
  label: "Sc√©nario 4 ‚Äî Accident de la voie publique",
  mission: "AVP multi-victimes",
  level: "‚Äî"
};

// ‚úÖ Sc√©nario suivant (Genially) ‚Äî remplace par ton vrai lien
const NEXT_SCENARIO_URL = "#";

const role = "medecin";
const roleLabelMap = { medecin:"M√©decin", infirmier:"Infirmier", pompier:"Pompier" };

/* ========= DIFFICULTY RULES ========= */
function normalizeDifficulty(raw){
  const v = String(raw||"").trim().toLowerCase();
  if(v.includes("expert")) return "expert";
  if(v.includes("inter")) return "intermediaire";
  if(v.includes("moy")) return "intermediaire";
  if(v.includes("debut")) return "debutant";
  if(v.includes("d√©but")) return "debutant";
  if(v === "1") return "debutant";
  if(v === "2") return "intermediaire";
  if(v === "3") return "expert";
  return "debutant";
}
function difficultyLabel(diff){
  if(diff==="expert") return "EXPERT";
  if(diff==="intermediaire") return "INTERM√âDIAIRE";
  return "D√âBUTANT";
}
function rulesForDifficulty(diff){
  if(diff==="expert") return { seconds: 30, attempts: 1, hints: 1 };
  if(diff==="intermediaire") return { seconds: 45, attempts: 2, hints: 2 };
  return { seconds: 60, attempts: 3, hints: 3 };
}

/* ========= INPUTS (player, avatar, difficulty) ========= */
const playerName =
  window.player_name ||
  window.playerName ||
  localStorage.getItem("player_name") ||
  localStorage.getItem("playerName") ||
  localStorage.getItem("playerName".toLowerCase()) ||
  "Joueur";

const avatarFile = localStorage.getItem("avatar") || "medecin_f.png";

const difficultyRaw =
  window.niveau ||
  localStorage.getItem("niveau") ||
  localStorage.getItem("difficulty") ||
  "debutant";

const difficulty = normalizeDifficulty(difficultyRaw);
const RULES = rulesForDifficulty(difficulty);

SCENARIO.level = "Niveau " + difficultyLabel(difficulty).toLowerCase();

levelTabText.textContent = difficultyLabel(difficulty);
difficultyChip.textContent = "MODE: " + difficultyLabel(difficulty);

miniTime.textContent = RULES.seconds + "s";     // miniHint
miniAttempts.textContent = String(RULES.attempts);
miniHints.textContent = String(RULES.hints);

hudName.textContent = "Dr. " + playerName;
hudRole.textContent = "R√¥le: " + (roleLabelMap[role] || "‚Äî");
hudAvatar.src = "assets/avatars/" + avatarFile;

/* ========= STORAGE ========= */
const HINT_KEY = `hints_left_s${SCENARIO.id}`;
const BADGE_KEY = `badge_s${SCENARIO.id}_${difficulty}`;
const HISTORY_KEY = "badges_history";

/* ========= STATE ========= */
let score = parseInt(localStorage.getItem("score") || "0", 10);
let stress = parseInt(localStorage.getItem("stress") || "0", 10);
if(isNaN(score)) score = 0;
if(isNaN(stress)) stress = 0;

let idx = 0;
let locked = true;
let paused = false;

let timerId = null;
let timeLeft = RULES.seconds;

let attemptsForCurrentQuestion = 1; // affichage (par question)
let missionErrors = 0;              // global mission
let missionTimeouts = 0;            // global mission

let hintsLeft = (() => {
  const v = parseInt(localStorage.getItem(HINT_KEY), 10);
  if(isNaN(v)) return RULES.hints;
  return clamp(v, 0, RULES.hints);
})();

let hintUsedThisQuestion = false;

/* ========= UI SYNC ========= */
function setScore(v){
  score = v;
  localStorage.setItem("score", String(score));
  hudScore.textContent = String(score);
  modalScore.textContent = String(score);
}
function addScore(d){ setScore(score + d); }
function setStress(v){
  stress = clamp(v,0,100);
  localStorage.setItem("stress", String(stress));
  stressBar.style.width = stress + "%";
  modalStress.textContent = String(stress);
}
function addStress(d){ setStress(stress + d); }

function setHintsLeft(v){
  hintsLeft = clamp(v, 0, RULES.hints);
  localStorage.setItem(HINT_KEY, String(hintsLeft));
  hintsLeftText.textContent = String(hintsLeft);
  hintOverlayLeft.textContent = String(hintsLeft);
  miniHints.textContent = String(hintsLeft);
  hintBtn.disabled = (hintsLeft<=0) || hintUsedThisQuestion || locked || paused || ended;
}

function setAttemptsUI(){
  hudAttempts.textContent = String(attemptsForCurrentQuestion);
  hudAttemptsMax.textContent = String(RULES.attempts);
  miniAttempts.textContent = String(RULES.attempts);
}

function setProgress(){
  const p = Math.round((idx / TOTAL) * 100);
  progressBar.style.width = clamp(p,0,100) + "%";
}

function setRingProgress(){
  const p = clamp(Math.round((timeLeft / RULES.seconds) * 100), 0, 100);
  ring.style.setProperty("--p", p + "%");
  timerPill.classList.remove("timerWarn","timerDanger");
  if(timeLeft <= 5) timerPill.classList.add("timerDanger");
  else if(timeLeft <= 10) timerPill.classList.add("timerWarn");
}

function updateButtonsEnabled(){
  pauseBtn.disabled = locked || ended;
  hintBtn.disabled = (hintsLeft<=0) || hintUsedThisQuestion || locked || paused || ended;
  showKeyBtn.disabled = !ended; // ‚úÖ activ√© seulement √† la fin
}

/* ========= TIMER ========= */
function stopTimer(){ if(timerId){ clearInterval(timerId); timerId=null; } }
function startTimer(){
  stopTimer();
  timeLeft = RULES.seconds;
  hudTime.textContent = String(timeLeft);
  setRingProgress();

  timerId = setInterval(()=>{
    if(locked || paused || ended) return;
    timeLeft--;
    hudTime.textContent = String(timeLeft);
    setRingProgress();
    if(timeLeft <= 0){
      stopTimer();
      sfxAlarmLong();
      missionTimeouts++;
      addStress(STRESS_RULES.timeout);

      attemptsForCurrentQuestion++;
      setAttemptsUI();

      if(missionTimeouts >= RULES.attempts){
        missionFail(`‚è±Ô∏è Temps √©coul√© trop de fois (${missionTimeouts}/${RULES.attempts}). Mission √©chou√©e. Retour au d√©part‚Ä¶ (score remis √† z√©ro)`);
        return;
      }

      if(attemptsForCurrentQuestion > RULES.attempts){
        missionFail(`‚è±Ô∏è Trop de tentatives sur cette question. Mission √©chou√©e. Retour au d√©part‚Ä¶ (score remis √† z√©ro)`);
        return;
      }

      showOverlay("warn", `‚è±Ô∏è Temps √©coul√©. (Timeout ${missionTimeouts}/${RULES.attempts})`, {allowRetry:true, allowNext:false, missionFail:false});
    }
  }, 1000);
}

/* ========= OVERLAYS ========= */
function showOverlay(kind, text, {allowRetry, allowNext, missionFail}){
  badgeState.className="badgeState";
  if(kind==="good"){ badgeState.classList.add("bGood"); badgeState.textContent="‚úÖ Bonne r√©ponse"; }
  if(kind==="warn"){ badgeState.classList.add("bWarn"); badgeState.textContent="‚ö†Ô∏è √Ä corriger"; }
  if(kind==="bad") { badgeState.classList.add("bBad");  badgeState.textContent="üö® Mission √©chou√©e"; }

  modalText.textContent = text;
  overlay.style.display="flex";

  retryBtn.style.display = allowRetry ? "inline-block" : "none";
  nextBtn.style.display  = allowNext  ? "inline-block" : "none";
  okBtn.style.display = "none";

  retryBtn.onclick = ()=>{
    hideOverlay();
    locked=false;
    paused=false;
    startTimer();
  };

  nextBtn.onclick = ()=>{
    hideOverlay();
    idx++;
    if(idx < TOTAL) renderQuestion(idx, true);
    else endScenario();
  };

  if(missionFail){
    retryBtn.style.display="none";
    nextBtn.style.display="none";
    okBtn.style.display="inline-block";
    okBtn.textContent="OK";
    okBtn.onclick = ()=>{
      hideOverlay();
      resetMission(true);
    };
  }
}
function hideOverlay(){ overlay.style.display="none"; }

function showHintOverlay(text){
  hintText.innerHTML = text;
  hintOverlay.style.display = "flex";
}
function hideHintOverlay(){ hintOverlay.style.display="none"; }

function showKeyOverlay(html){
  keyBody.innerHTML = html;
  keyOverlay.style.display = "flex";
}
function hideKeyOverlay(){ keyOverlay.style.display="none"; }

/* ========= MOTION ========= */
function motion(type){
  frame.classList.remove("shake","pulseGood","flashBad");
  modalBox.classList.remove("shake","pulseGood","flashBad");
  if(type==="good"){ frame.classList.add("pulseGood"); }
  else if(type==="wrong"){ modalBox.classList.add("shake"); }
  else if(type==="critical"){ modalBox.classList.add("shake"); frame.classList.add("flashBad"); }
}

/* ========= STRESS ========= */
const STRESS_RULES = { wrong: 10, timeout: 15, critical: 25 };

/* ========= QUESTIONS ========= */
const questions = [
  {
    "type": "single",
    "title": "Briefing m√©decin ‚Äî arriv√©e sur AVP",
    "desc": "En tant que m√©decin, quelle est ta toute premi√®re priorit√© avant tout geste m√©dical ?",
    "options": [
      { "text": "Commencer imm√©diatement une intubation sur la premi√®re victime", "kind": "wrong", "fb": "‚ùå Trop t√¥t : d‚Äôabord s√©curit√© de la sc√®ne + triage." },
      { "text": "S√©curiser la sc√®ne (risques) puis organiser le triage", "kind": "ok", "fb": "‚úÖ Oui : s√©curit√© + triage avant les gestes sp√©cialis√©s." },
      { "text": "Rassembler les t√©moins pour reconstituer l‚Äôaccident", "kind": "wrong", "fb": "‚ùå Utile plus tard, pas en priorit√©." },
      { "text": "Donner des antalgiques √† tous les bless√©s", "kind": "wrong", "fb": "‚ùå Avant tout : triage + menaces vitales." }
    ]
  },
  {
    "type": "multi",
    "title": "Menaces vitales (ABCDE)",
    "desc": "S√©lectionne les menaces vitales imm√©diates √† traiter en priorit√© :",
    "options": [
      { "text": "H√©morragie massive", "correct": true },
      { "text": "Absence/inefficacit√© respiratoire", "correct": true },
      { "text": "Douleur isol√©e sans d√©tresse", "correct": false },
      { "text": "Alt√©ration de conscience", "correct": true }
    ],
    "okFb": "‚úÖ Correct : A/B + h√©morragie + conscience.",
    "badFb": "‚ùå Priorit√© : respiration + h√©morragie + conscience."
  },
  {
    "type": "tf",
    "title": "Zone dangereuse",
    "desc": "Tu dois s√©curiser la zone AVANT d‚Äôapprocher une victime.",
    "tf": {
      "trueOpt": { "kind": "ok", "fb": "‚úÖ Oui : s√©curit√© sc√®ne prioritaire." },
      "falseOpt": { "kind": "wrong", "fb": "‚ùå Non : on s√©curise avant d‚Äôintervenir." },
      "correct": true
    },
    "okFb": "‚úÖ Correct.",
    "badFb": "‚ùå Incorrect."
  },
  {
    "type": "image_single",
    "title": "Triage START ‚Äî priorit√© IMMEDIATE",
    "desc": "Choisis l‚Äôimage correspondant √† une victime en d√©tresse vitale (IMMEDIATE).",
    "options": [
      { "label": "A", "imgSrc": "assets/avp_q4_b.png", "kind": "ok", "fb": "‚úÖ D√©tresse respiratoire = IMMEDIATE.", "caption": "Inconscient / respiration anormale" },
      { "label": "B", "imgSrc": "assets/avp_q4_a.png", "kind": "wrong", "fb": "‚ùå Non : victime stable pour l‚Äôinstant.", "caption": "Conscient / respiration normale" },
      { "label": "C", "imgSrc": "assets/avp_q4_c.png", "kind": "wrong", "fb": "‚ùå Non : priorit√© apr√®s contr√¥le simple.", "caption": "Conscient / h√©morragie externe contr√¥lable" }
    ]
  },
  {
    "type": "single",
    "title": "H√©morragie massive",
    "desc": "Chez une victime qui saigne abondamment, le geste imm√©diat le plus efficace est :",
    "options": [
      { "text": "Compression directe forte + pansement compressif", "kind": "ok", "fb": "‚úÖ Oui : stopper le saignement imm√©diatement." },
      { "text": "Nettoyer longuement avec antiseptique", "kind": "wrong", "fb": "‚ùå Perte de temps, priorit√© au contr√¥le du saignement." },
      { "text": "Mettre de la glace sur la plaie", "kind": "wrong", "fb": "‚ùå Insuffisant en h√©morragie massive." },
      { "text": "Attendre l‚Äôarriv√©e d‚Äôune √©quipe sp√©cialis√©e", "kind": "wrong", "fb": "‚ùå Il faut agir tout de suite." }
    ]
  },
  {
    "type": "multi",
    "title": "Alerte m√©dicale structur√©e",
    "desc": "Pour une alerte efficace au SAMU/SMUR, tu transmets :",
    "options": [
      { "text": "Localisation pr√©cise + acc√®s", "correct": true },
      { "text": "Nombre de victimes + gravit√© (triage)", "correct": true },
      { "text": "Couleur des v√©hicules", "correct": false },
      { "text": "Risques persistants (feu, trafic, √©lectrique)", "correct": true }
    ],
    "okFb": "‚úÖ Oui : lieu + nb/gravit√© + risques.",
    "badFb": "‚ùå Attendu : lieu + nb/gravit√© + risques."
  },
  {
    "type": "cloze",
    "title": "Transmission (m√©decin) ‚Äî 2 infos cl√©s",
    "desc": "Compl√®te 2 informations essentielles √† transmettre :",
    "template": "M√©canisme : <b>{blank1}</b> ‚Ä¢ Nb victimes : <b>{blank2}</b>.",
    "blanks": [
      { "key": "blank1", "answer": "haute √©nergie" },
      { "key": "blank2", "answer": "3" }
    ],
    "okFb": "‚úÖ Parfait : m√©canisme + nombre de victimes.",
    "badFb": "‚ùå Attendu : haute √©nergie / 3."
  },
  {
    "type": "tf",
    "title": "Boisson (pi√®ge)",
    "desc": "Peux-tu donner √† boire √† une victime polytraumatis√©e consciente ?",
    "tf": {
      "trueOpt": { "kind": "wrong", "fb": "‚ùå Non : risque d‚Äôaspiration et chirurgie/anesth√©sie possible." },
      "falseOpt": { "kind": "ok", "fb": "‚úÖ Correct : pas de boisson. Rassurer et surveiller." },
      "correct": false
    },
    "okFb": "‚úÖ Bonne r√©ponse.",
    "badFb": "‚ùå Mauvais choix."
  },
  {
    "type": "hotspot",
    "gate": true,
    "title": "Hotspot ‚Äî A (Airway) + protection cervicale",
    "desc": "Clique la zone associ√©e √† la priorit√© A (voies a√©riennes / t√™te-cou).",
    "imgSrc": "scenario_4_hotspot_q_9.png",
    "hotspots": [
      { "label": "cou/t√™te", "x": 25, "y": 48, "w": 12, "h": 16, "kind": "ok", "fb": "‚úÖ Oui : t√™te/cou = A + protection cervicale." },
      { "label": "jambe", "x": 52, "y": 78, "w": 12, "h": 16, "kind": "wrong", "fb": "‚ùå Ici, on vise la zone A : t√™te/cou." },
      { "label": "bras", "x": 52, "y": 50, "w": 12, "h": 16, "kind": "wrong", "fb": "‚ùå Ici, on vise la zone A : t√™te/cou." }
    ]
  },
  {
    "type": "image_single",
    "title": "D√©cision clinique imm√©diate (m√©decin)",
    "desc": "Choisis la conduite la plus s√ªre (polytraumatis√©) :",
    "options": [
      { "label": "A", "imgSrc": "assets/avp_q4_a.png", "kind": "wrong", "fb": "‚ùå Non : risque d‚Äôaggraver une l√©sion rachidienne.", "caption": "Mobilisation non contr√¥l√©e" },
      { "label": "B", "imgSrc": "assets/avp_q4_c.png", "kind": "ok", "fb": "‚úÖ Maintien axe t√™te-cou-tronc + surveillance + alerte.", "caption": "Maintien axe t√™te-cou-tronc + surveillance + alerte" },
      { "label": "C", "imgSrc": "assets/avp_q4_b.png", "kind": "wrong", "fb": "‚ùå Non : priorit√© aux gestes vitaux/immobilisation, pas de manoeuvre inadapt√©e.", "caption": "Geste inadapt√© / non prioritaire" }
    ]
  },
  {
    "type": "multi",
    "title": "Surveillance m√©dicale",
    "desc": "Quels param√®tres sont prioritaires √† surveiller ?",
    "options": [
      { "text": "Conscience (GCS/AVPU)", "correct": true },
      { "text": "Respiration (FR/qualit√©)", "correct": true },
      { "text": "Perfusion / saignements", "correct": true },
      { "text": "Couleur des yeux", "correct": false }
    ],
    "okFb": "‚úÖ Conscience/respiration/perfusion.",
    "badFb": "‚ùå Attendu : conscience + respiration + perfusion."
  },
  {
    "type": "single",
    "title": "Oxyg√®ne",
    "desc": "Tu administres de l‚Äôoxyg√®ne en priorit√© si :",
    "options": [
      { "text": "Victime stable, FR normale", "kind": "wrong", "fb": "‚ùå Non prioritaire." },
      { "text": "D√©tresse respiratoire / SpO‚ÇÇ basse si mesur√©e", "kind": "ok", "fb": "‚úÖ Oui : O‚ÇÇ si d√©tresse/SpO‚ÇÇ basse." },
      { "text": "Douleur isol√©e", "kind": "wrong", "fb": "‚ùå Pas une indication seule." },
      { "text": "Sur demande d‚Äôun t√©moin", "kind": "wrong", "fb": "‚ùå Non." }
    ]
  },
  {
    "type": "tf",
    "title": "Casque",
    "desc": "On retire un casque syst√©matiquement apr√®s AVP.",
    "tf": {
      "trueOpt": { "kind": "wrong", "fb": "‚ùå Faux : on √©vite sans indication (risque rachis)." },
      "falseOpt": { "kind": "ok", "fb": "‚úÖ Exact : seulement si n√©cessaire/selon protocole." },
      "correct": false
    },
    "okFb": "‚úÖ Exact.",
    "badFb": "‚ùå Faux."
  },
  {
    "type": "multi",
    "title": "Erreur critique",
    "desc": "S√©lectionne l‚Äôaction dangereuse :",
    "options": [
      { "text": "Relever une victime sans immobilisation", "correct": true },
      { "text": "Couvrir et isoler du sol", "correct": false },
      { "text": "Compression d‚Äôh√©morragie massive", "correct": false },
      { "text": "Alerte pr√©coce structur√©e", "correct": false }
    ],
    "okFb": "üö® Oui : relever sans immobiliser = erreur critique.",
    "badFb": "‚ùå L‚Äôerreur critique est de relever sans immobiliser."
  },
  {
    "type": "hotspot",
    "gate": true,
    "title": "Hotspot ‚Äî Immobilisation priorit√© (rachis)",
    "desc": "Clique la zone √† immobiliser en priorit√© :",
    "imgSrc": "scenario_4_hotspot_q_15.png",
    "hotspots": [
      { "label": "rachis", "x": 60, "y": 54, "w": 10, "h": 35, "kind": "ok", "fb": "‚úÖ Oui : rachis/colonne vert√©brale." },
      { "label": "genou", "x": 65, "y": 90, "w": 12, "h": 12, "kind": "wrong", "fb": "‚ùå Zone critique : rachis." },
      { "label": "√©paule", "x": 52, "y": 40, "w": 12, "h": 12, "kind": "wrong", "fb": "‚ùå Zone critique : rachis." }
    ]
  },
  {
    "type": "single",
    "title": "Hypothermie",
    "desc": "Pour limiter le choc, tu dois en priorit√© :",
    "options": [
      { "text": "Couvrir et isoler du sol", "kind": "ok", "fb": "‚úÖ Oui : pr√©venir l‚Äôhypothermie." },
      { "text": "Laisser √† l‚Äôair", "kind": "wrong", "fb": "‚ùå Risque d‚Äôhypothermie." },
      { "text": "Mettre debout", "kind": "wrong", "fb": "‚ùå Dangereux." },
      { "text": "Donner boisson chaude", "kind": "wrong", "fb": "‚ùå Interdit en polytrauma." }
    ]
  },
  {
    "type": "image_single",
    "title": "Geste s√ªr ‚Äî pr√©vention hypothermie",
    "desc": "Quelle image montre le meilleur geste :",
    "options": [
      { "label": "A", "imgSrc": "assets/avp_q17_a.png", "kind": "wrong", "fb": "‚ùå Non.", "caption": "Victime non prot√©g√©e" },
      { "label": "B", "imgSrc": "assets/avp_q17_c.png", "kind": "wrong", "fb": "‚ùå Non.", "caption": "Exposition au froid" },
      { "label": "C", "imgSrc": "assets/avp_q17_b.png", "kind": "ok", "fb": "‚úÖ Couvrir/isoler = bon geste.", "caption": "Couvrir / isoler (pr√©venir hypothermie)" }
    ]
  },
  {
    "type": "short",
    "title": "Num√©ro m√©dical",
    "desc": "Quel num√©ro appelles-tu pour l‚Äôaide m√©dicale urgente ? (1 nombre)",
    "answers": ["15"],
    "okFb": "‚úÖ 15.",
    "badFb": "‚ùå Attendu : 15."
  },
  {
    "type": "tf",
    "title": "R√©√©valuation",
    "desc": "En attendant le SAMU, tu r√©√©values r√©guli√®rement l‚Äô√©tat des victimes.",
    "tf": {
      "trueOpt": { "kind": "ok", "fb": "‚úÖ Vrai : r√©√©valuer jusqu‚Äô√† l‚Äôarriv√©e des secours." },
      "falseOpt": { "kind": "wrong", "fb": "‚ùå Faux : surveillance continue obligatoire." },
      "correct": true
    },
    "okFb": "‚úÖ Vrai.",
    "badFb": "‚ùå Faux."
  },
  {
    "type": "single",
    "title": "D√©cision finale",
    "desc": "Avant l‚Äôarriv√©e du SMUR, la priorit√© m√©dicale la plus pertinente est :",
    "options": [
      { "text": "R√©√©valuer ABC + surveiller signes de choc", "kind": "ok", "fb": "‚úÖ Priorit√© : r√©√©valuation + choc." },
      { "text": "Soins de confort", "kind": "wrong", "fb": "‚ùå Secondaire." },
      { "text": "D√©placer les victimes", "kind": "wrong", "fb": "‚ùå Dangereux." },
      { "text": "Attendre sans intervenir", "kind": "wrong", "fb": "‚ùå Non." }
    ]
  }
];

const TOTAL = questions.length;
hudQtotal.textContent = String(TOTAL);

/* ========= SELECTION STATE ========= */
let selectedSingle = null;
let multiSelected = new Set();
let inputValue = "";
let clozeValues = {};
let ended = false;

/* ========= RENDER HELPERS ========= */
function resetSelection(){
  selectedSingle = null;
  multiSelected.clear();
  inputValue = "";
  clozeValues = {};
  validateBtn.disabled = true;
  hintUsedThisQuestion = false;
  setHintsLeft(hintsLeft);
}

function mkOpt(text){
  const d = document.createElement("div");
  d.className = "opt";
  d.textContent = text;
  return d;
}

function renderQuestion(i, resetAttempts=true){
  ended = false;
  locked = false;
  paused = false;

  stopTimer();
  hideOverlay();
  hideHintOverlay();
  hideKeyOverlay();

  if(resetAttempts){
    attemptsForCurrentQuestion = 1;
    setAttemptsUI();
  }

  resetSelection();
  updateButtonsEnabled();

  const q = questions[i];

  qMeta.textContent = `${SCENARIO.label} ‚Ä¢ ${difficultyLabel(difficulty)} ‚Ä¢ ${roleLabelMap[role] || "‚Äî"}`;
  qTitle.textContent = q.title || "‚Äî";
  qDesc.innerHTML = q.desc || "";
  optionsEl.innerHTML = "";
  clearBtn.style.display = "none";

  setProgress();
  hudQnum.textContent = String(i+1);

  // Render type
  const type = q.type;

  if(type==="single"){
    q.options.forEach((opt, oi)=>{
      const d = mkOpt(opt.text);
      d.onclick = ()=>{
        if(locked || paused) return;
        sfxClick();
        [...optionsEl.children].forEach(x=>x.classList.remove("sel"));
        d.classList.add("sel");
        selectedSingle = oi;
        validateBtn.disabled = false;
      };
      optionsEl.appendChild(d);
    });
  }

  if(type==="tf"){
    const opts=[{label:"Vrai",data:q.tf.trueOpt},{label:"Faux",data:q.tf.falseOpt}];
    opts.forEach((o, oi)=>{
      const d = mkOpt(o.label);
      d.onclick = ()=>{
        if(locked || paused) return;
        sfxClick();
        [...optionsEl.children].forEach(x=>x.classList.remove("sel"));
        d.classList.add("sel");
        selectedSingle = oi;
        validateBtn.disabled = false;
      };
      optionsEl.appendChild(d);
    });
  }

  if(type==="multi"){
    clearBtn.style.display = "inline-block";
    q.options.forEach((opt, oi)=>{
      const d = mkOpt(opt.text);
      d.onclick = ()=>{
        if(locked || paused) return;
        sfxClick();
        if(multiSelected.has(oi)){
          multiSelected.delete(oi); d.classList.remove("sel");
        }else{
          multiSelected.add(oi); d.classList.add("sel");
        }
        validateBtn.disabled = (multiSelected.size===0);
      };
      optionsEl.appendChild(d);
    });
  }

  if(type==="short"){
    clearBtn.style.display = "inline-block";
    const box = document.createElement("div");
    box.className = "opt";
    box.style.cursor = "default";
    box.innerHTML = `
      <div style="font-weight:950; margin-bottom:8px;">Ta r√©ponse</div>
      <input id="shortInput" class="form-control" type="text" placeholder="√âcris ici‚Ä¶"
        style="background: rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.18); color: rgba(255,255,255,.92);" />
      <div style="margin-top:8px; font-size:12px; color: rgba(255,255,255,.72);">Astuce : une valeur courte suffit.</div>
    `;
    optionsEl.appendChild(box);
    const inp = box.querySelector("#shortInput");
    inp.addEventListener("input", ()=>{
      inputValue = inp.value;
      validateBtn.disabled = (inp.value.trim().length===0) || locked || paused;
    });
  }

  if(type==="image_single"){
    const grid = document.createElement("div");
    grid.className = "imgGrid";
    q.options.forEach((opt, oi)=>{
      const card = document.createElement("div");
      card.className = "imgCard";
      card.innerHTML = `
        <div class="imgHead">
          <div>Option ${escapeHtml(opt.label || String(oi+1))}</div>
          <div class="imgTag">${escapeHtml(opt.label || String(oi+1))}</div>
        </div>
        <img class="imgPic" src="${escapeHtml(opt.imgSrc)}" alt="Option ${escapeHtml(opt.label||"")}" />
        <div class="imgCap">${escapeHtml(opt.caption || "")}</div>
      `;
      card.onclick = ()=>{
        if(locked || paused) return;
        sfxClick();
        [...grid.querySelectorAll(".imgCard")].forEach(c=>c.classList.remove("sel"));
        card.classList.add("sel");
        selectedSingle = oi;
        validateBtn.disabled = false;
      };
      grid.appendChild(card);
    });
    optionsEl.appendChild(grid);
  }

  if(type==="hotspot"){
    clearBtn.style.display = "inline-block";

    const msg = document.createElement("div");
    msg.className="pill";
    msg.style.marginBottom="6px";
    msg.innerHTML = "üéØ <b>Clique sur la zone correcte</b> sur l‚Äôimage, puis appuie sur <b>Valider</b>.";
    optionsEl.appendChild(msg);

    const wrap = document.createElement("div");
    wrap.style.position="relative";
    wrap.style.width="100%";
    wrap.style.maxWidth="640px";
    wrap.style.margin="0 auto";
    wrap.style.borderRadius="18px";
    wrap.style.overflow="hidden";
    wrap.style.border="1px solid rgba(255,255,255,.14)";
    wrap.style.background="rgba(0,0,0,.18)";
    wrap.innerHTML = `<img src="${escapeHtml(q.imgSrc||"")}" alt="hotspot" style="width:100%; height:240px; display:block;">`;
    optionsEl.appendChild(wrap);

    const zones = document.createElement("div");
    zones.style.position="absolute";
    zones.style.inset="0";
    zones.style.pointerEvents="auto";
    wrap.appendChild(zones);

    selectedSingle = null;
    validateBtn.disabled = true;

    (q.hotspots||[]).forEach((h, hi)=>{
      const z = document.createElement("button");
      z.type="button";
      z.className="hotspot-zone";
      z.style.left = h.x + "%";
      z.style.top  = h.y + "%";
      z.style.width = h.w + "%";
      z.style.height= h.h + "%";
      z.style.borderRadius = (h.r||16) + "px";

      z.onclick = ()=>{
        if(locked || paused) return;
        sfxClick();
        [...zones.querySelectorAll("button")].forEach(b=>b.classList.remove("sel"));
        z.classList.add("sel");
        selectedSingle = hi;
        validateBtn.disabled = false;
      };
      zones.appendChild(z);
    });
  }

  if(type==="cloze"){
    clearBtn.style.display="inline-block";
    const box = document.createElement("div");
    box.className="opt";
    box.style.cursor="default";

    const html = (q.template||"")
      .replace("{blank1}", `<input data-k="blank1" class="form-control" style="display:inline-block; width:240px; margin:0 6px; background: rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.18); color: rgba(255,255,255,.92);" placeholder="..." />`)
      .replace("{blank2}", `<input data-k="blank2" class="form-control" style="display:inline-block; width:260px; margin:0 6px; background: rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.18); color: rgba(255,255,255,.92);" placeholder="..." />`);

    box.innerHTML = `<div style="line-height:1.9;">${html}</div>
      <div style="margin-top:8px; font-size:12px; color: rgba(255,255,255,.72);">Astuce : exemple "10".</div>`;
    optionsEl.appendChild(box);

    const inputs = box.querySelectorAll("input[data-k]");
    inputs.forEach(inp=>{
      inp.addEventListener("input", ()=>{
        clozeValues[inp.dataset.k] = inp.value;
        const filled = (q.blanks||[]).every(b => (clozeValues[b.key]||"").trim().length>0);
        validateBtn.disabled = !filled || locked || paused;
      });
    });
  }

  // reset clear
  clearBtn.onclick = ()=>{
    if(locked || paused) return;
    sfxClick();
    renderQuestion(idx, false);
  };

  // buttons enabled
  updateButtonsEnabled();

  // timer
  startTimer();
}

/* ========= EVALUATION ========= */
function failedAttempt(baseMsg){
  attemptsForCurrentQuestion++;
  setAttemptsUI();

  // Global mission error count
  missionErrors++;

  if(missionErrors >= RULES.attempts){
    sfxAlarmLong();
    missionFail(`‚ùå Trop d‚Äôerreurs (${missionErrors}/${RULES.attempts}). Mission √©chou√©e. Retour au d√©part‚Ä¶ (score remis √† z√©ro)`);
    return;
  }

  if(attemptsForCurrentQuestion > RULES.attempts){
    sfxAlarmLong();
    missionFail(`‚ùå Tentatives √©puis√©es sur cette question. Mission √©chou√©e. Retour au d√©part‚Ä¶ (score remis √† z√©ro)`);
    return;
  }

  showOverlay("warn", `${baseMsg} (Tentative ${attemptsForCurrentQuestion}/${RULES.attempts})`, {allowRetry:true, allowNext:false, missionFail:false});
}

function evaluateOption(opt){
  if(opt.kind==="ok"){
    addScore(opt.pts ?? 10);
    sfxCorrect();
    motion("good");
    showOverlay("good", opt.fb || "‚úÖ Correct.", {allowRetry:false, allowNext:true, missionFail:false});
    return;
  }
  if(opt.kind==="critical"){
    addStress(STRESS_RULES.critical);
    addScore(opt.pts ?? -10);
    sfxCritical();
    motion("critical");
    failedAttempt(opt.fb || "üö® Erreur critique.");
    return;
  }
  // wrong/partial
  addStress(STRESS_RULES.wrong);
  sfxWrong();
  motion("wrong");
  failedAttempt(opt.fb || "‚ùå Incorrect.");
}

validateBtn.onclick = ()=>{
  if(locked || paused || ended) return;

  const q = questions[idx];
  const type = q.type;

  const needSelection = (msg)=>{
    sfxClick();
    stopTimer();
    locked = true;
    showOverlay("warn", msg, {allowRetry:false, allowNext:false, missionFail:false});
    retryBtn.style.display="none";
    nextBtn.style.display="none";
    okBtn.style.display="inline-block";
    okBtn.textContent="OK";
    okBtn.onclick = ()=>{
      hideOverlay();
      locked=false;
      startTimer();
      updateButtonsEnabled();
    };
  };

  if(type==="single" || type==="tf" || type==="image_single" || type==="hotspot"){
    if(selectedSingle===null){ needSelection("Choisis une r√©ponse avant de valider."); return; }
  }
  if(type==="multi"){
    if(multiSelected.size===0){ needSelection("S√©lectionne au moins une proposition avant de valider."); return; }
  }
  if(type==="short"){
    if((inputValue||"").trim().length===0){ needSelection("√âcris une r√©ponse avant de valider."); return; }
  }
  if(type==="cloze"){
    const filled = (q.blanks||[]).every(b => ((clozeValues[b.key]||"").trim().length>0));
    if(!filled){ needSelection("Compl√®te tous les trous avant de valider."); return; }
  }

  stopTimer();
  locked = true;
  updateButtonsEnabled();

  if(type==="single"){
    evaluateOption(q.options[selectedSingle]); return;
  }

  if(type==="tf"){
    const opt = (selectedSingle===0) ? q.tf.trueOpt : q.tf.falseOpt;
    evaluateOption(opt); return;
  }

  if(type==="image_single"){
    evaluateOption(q.options[selectedSingle]); return;
  }

  if(type==="hotspot"){
    const h = (q.hotspots||[])[selectedSingle];
    if(!h){ locked=false; startTimer(); return; }
    evaluateOption(h); return;
  }

  if(type==="multi"){
    const chosen=[...multiSelected].sort((a,b)=>a-b);
    const correctIdx=(q.options||[]).map((o,i)=>o.correct?i:null).filter(v=>v!==null);
    const ok = chosen.length===correctIdx.length && chosen.every((v,i)=>v===correctIdx[i]);
    if(ok){
      addScore(10);
      sfxCorrect(); motion("good");
      showOverlay("good", q.okFb || "‚úÖ Correct.", {allowRetry:false, allowNext:true, missionFail:false});
    }else{
      addStress(STRESS_RULES.wrong);
      sfxWrong(); motion("wrong");
      failedAttempt(q.badFb || "‚ùå Incorrect.");
    }
    return;
  }

  if(type==="short"){
    const norm=(inputValue||"").trim().toLowerCase();
    const accepted=(q.answers||[]).map(a=>String(a).trim().toLowerCase());
    const ok = accepted.includes(norm);
    if(ok){
      addScore(10);
      sfxCorrect(); motion("good");
      showOverlay("good", q.okFb || "‚úÖ Bonne r√©ponse.", {allowRetry:false, allowNext:true, missionFail:false});
    }else{
      addStress(STRESS_RULES.wrong);
      sfxWrong(); motion("wrong");
      failedAttempt(q.badFb || "‚ùå R√©ponse incorrecte.");
    }
    return;
  }

  if(type==="cloze"){
    const ok = (q.blanks||[]).every(b => ((clozeValues[b.key]||"").trim().toLowerCase() === String(b.answer||"").trim().toLowerCase()));
    if(ok){
      addScore(10);
      sfxCorrect(); motion("good");
      showOverlay("good", q.okFb || "‚úÖ Correct.", {allowRetry:false, allowNext:true, missionFail:false});
    }else{
      addStress(STRESS_RULES.wrong);
      sfxWrong(); motion("wrong");
      failedAttempt(q.badFb || "‚ùå Texte incorrect.");
    }
    return;
  }
};

/* ========= HINT SYSTEM (1 / question) ========= */
function computeHintForQuestion(q){
  // Affiche la BONNE r√©ponse (comme ‚Äúindice sur la r√©ponse‚Äù)
  if(q.hint) return `üß† <b>Indice :</b> ${escapeHtml(q.hint)}`;

  if(q.type==="single"){
    const ok = (q.options||[]).find(o=>o.kind==="ok");
    return `üß† <b>Indice :</b> la bonne r√©ponse est :<br><br>‚úÖ <b>${escapeHtml(ok ? ok.text : "‚Äî")}</b>`;
  }

  if(q.type==="tf"){
    const okIsTrue = (q.tf && q.tf.trueOpt && q.tf.trueOpt.kind==="ok");
    return `üß† <b>Indice :</b> la bonne r√©ponse est :<br><br>‚úÖ <b>${okIsTrue ? "Vrai" : "Faux"}</b>`;
  }

  if(q.type==="multi"){
    const goods = (q.options||[]).filter(o=>o.correct).map(o=>o.text);
    return `üß† <b>Indice :</b> s√©lectionne :<br><br>‚úÖ <b>${escapeHtml(goods.join(" ; ") || "‚Äî")}</b>`;
  }

  if(q.type==="short"){
    const a = (q.answers||[])[0] || "‚Äî";
    return `üß† <b>Indice :</b> la r√©ponse attendue est : <b>${escapeHtml(a)}</b>`;
  }

  if(q.type==="cloze"){
    const a = (q.blanks||[]).map(b=>b.answer).join(" | ");
    return `üß† <b>Indice :</b> les mots attendus sont :<br><br>‚úÖ <b>${escapeHtml(a || "‚Äî")}</b>`;
  }

  if(q.type==="image_single"){
    const ok = (q.options||[]).find(o=>o.kind==="ok");
    return `üß† <b>Indice :</b> choisis :<br><br>‚úÖ <b>Option ${escapeHtml(ok ? ok.label : "‚Äî")}</b> ‚Äî ${escapeHtml(ok ? (ok.caption||"") : "")}`;
  }

  if(q.type==="hotspot"){
    const ok = (q.hotspots||[]).find(h=>h.kind==="ok");
    return `üß† <b>Indice :</b> clique la zone : <b>${escapeHtml(ok ? ok.label : "‚Äî")}</b>`;
  }

  return `üß† <b>Indice :</b> r√©fl√©chis aux priorit√©s (s√©curit√©, ABCDE, triage).`;
}

hintBtn.onclick = ()=>{
  if(locked || paused || ended) return;
  if(hintsLeft <= 0) return;
  if(hintUsedThisQuestion) return;

  ensureAudio();
  sfxClick();

  // consume
  hintUsedThisQuestion = true;
  setHintsLeft(hintsLeft - 1);

  // pause timer
  paused = true;
  updateButtonsEnabled();

  const q = questions[idx];
  showHintOverlay(computeHintForQuestion(q));
};

hintOkBtn.onclick = ()=>{
  hideHintOverlay();
  paused = false;
  updateButtonsEnabled();
};
hintCloseBtn.onclick = hintOkBtn.onclick;

/* ========= PAUSE ========= */
pauseBtn.onclick = ()=>{
  if(locked || ended) return;
  ensureAudio(); sfxClick();
  paused = !paused;

  if(paused){
    // use overlay feedback style for pause
    stopTimer();
    showOverlay("warn", "‚è∏ Pause. Clique sur OK pour reprendre.", {allowRetry:false, allowNext:false, missionFail:false});
    retryBtn.style.display="none";
    nextBtn.style.display="none";
    okBtn.style.display="inline-block";
    okBtn.textContent="OK";
    okBtn.onclick = ()=>{
      hideOverlay();
      paused = false;
      locked = false;
      startTimer();
      updateButtonsEnabled();
    };
  }else{
    hideOverlay();
    locked = false;
    startTimer();
  }

  updateButtonsEnabled();
};

/* ========= MISSION FAIL / RESET ========= */
function missionFail(message){
  stopTimer();
  locked = true;
  paused = false;
  updateButtonsEnabled();
  showOverlay("bad", message, {allowRetry:false, allowNext:false, missionFail:true});
  motion("critical");
}

function resetMission(showStart=true){
  stopTimer();
  idx = 0;
  attemptsForCurrentQuestion = 1;
  missionErrors = 0;
  missionTimeouts = 0;
  hintUsedThisQuestion = false;

  setScore(0);
  setStress(0);
  setHintsLeft(RULES.hints);

  locked = true;
  paused = false;
  ended = false;

  setProgress();
  hudQnum.textContent = "1";
  hudTime.textContent = String(RULES.seconds);
  ring.style.setProperty("--p","100%");
  setRingProgress();

  validateBtn.disabled = true;
  clearBtn.style.display = "none";
  showKeyBtn.disabled = true;
  endBtn.style.display = "none";

  if(showStart) startOverlay.style.display = "flex";
  updateButtonsEnabled();
}

/* ========= KEY / ANSWERS ========= */
function buildAnswerKey(){
  const rows = questions.map((q, i)=>{
    let ans = "";
    if(q.type==="single" || q.type==="image_single"){
      const oi = (q.options||[]).findIndex(o=>o.kind==="ok");
      if(q.type==="image_single"){
        ans = oi>=0 ? `${q.options[oi].label} ‚Äî ${q.options[oi].caption || ""}` : "‚Äî";
      }else{
        ans = oi>=0 ? (q.options[oi].text || "‚Äî") : "‚Äî";
      }
    }else if(q.type==="tf"){
      ans = (q.tf && q.tf.trueOpt && q.tf.trueOpt.kind==="ok") ? "Vrai" : "Faux";
    }else if(q.type==="multi"){
      const a = (q.options||[]).filter(o=>o.correct).map(o=>o.text);
      ans = a.join(" ; ");
    }else if(q.type==="short"){
      ans = (q.answers||[]).join(" / ");
    }else if(q.type==="cloze"){
      ans = (q.blanks||[]).map(b=>b.answer).join(" | ");
    }else if(q.type==="hotspot"){
      const okHs = (q.hotspots||[]).find(h=>h.kind==="ok");
      ans = okHs ? okHs.label : "‚Äî";
    }else{
      ans = "‚Äî";
    }

    return `<tr>
      <td style="padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.08); width:56px; color: rgba(255,255,255,.75);">Q${i+1}</td>
      <td style="padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.08); font-weight:900;">${escapeHtml(q.title||"")}</td>
      <td style="padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.08); color: rgba(255,255,255,.86);">${escapeHtml(ans)}</td>
    </tr>`;
  }).join("");

  return `
    <div style="font-weight:950; font-size:16px; margin-bottom:10px;">üìò Corrig√© (bonnes r√©ponses)</div>
    <div style="overflow:auto; border-radius:14px; border:1px solid rgba(255,255,255,.12);">
      <table style="width:100%; border-collapse:collapse; min-width:720px;">
        <thead>
          <tr>
            <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.12); color: rgba(255,255,255,.65); font-size:12px;">#</th>
            <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.12); color: rgba(255,255,255,.65); font-size:12px;">Question</th>
            <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.12); color: rgba(255,255,255,.65); font-size:12px;">Bonne r√©ponse</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    </div>
  `;
}

showKeyBtn.onclick = ()=>{
  if(!ended) return;
  ensureAudio(); sfxClick();
  showKeyOverlay(buildAnswerKey());
};
keyCloseBtn.onclick = ()=>{ hideKeyOverlay(); };
keyOkBtn.onclick = ()=>{ hideKeyOverlay(); };

/* ========= BADGE (FIN) ========= */
function computeBadgeFromScore(score){
  // score max th√©orique ‚âà 20*10 = 200
  const pct = clamp(Math.round((score / (TOTAL*10)) * 100), 0, 100);
  if(pct >= 90) return { type:"OR", img:"assets/or.png", pct };
  if(pct >= 70) return { type:"ARGENT", img:"assets/argent.png", pct };
  return { type:"BRONZE", img:"assets/bronze.png", pct };
}
function saveBadge(badge){
  const payload = {
    scenarioId: SCENARIO.id,
    mission: SCENARIO.mission,
    niveau: difficultyLabel(difficulty),
    badgeType: badge.type,
    badgeName: `${badge.type} ‚Äî ${SCENARIO.mission}`,
    score,
    img: badge.img,
    ts: Date.now(),
    dateISO: new Date().toISOString()
  };

  localStorage.setItem(BADGE_KEY, JSON.stringify(payload));

  const prev = (() => {
    try{ return JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]"); }
    catch(e){ return []; }
  })();
  prev.push(payload);
  localStorage.setItem(HISTORY_KEY, JSON.stringify(prev));
}

function endScenario(){
  stopTimer();
  hideOverlay();
  hideHintOverlay();

  ended = true;
  locked = true;
  paused = false;

  // badge
  const badge = computeBadgeFromScore(score);
  saveBadge(badge);
  sfxVictory();

  qMeta.textContent = "FIN ‚Äî BADGE OBTENU";
  qTitle.textContent = "üéâ F√©licitations !";

  const stressState = (stress>=80) ? "üî¥ Pression extr√™me" : (stress>=40) ? "üü° Sous pression" : "üü¢ Calme";

  qDesc.innerHTML = `
    <div style="margin-top:6px; color: rgba(255,255,255,.86);">
      <div style="font-weight:950; font-size:16px;">üèÖ Badge ${escapeHtml(badge.type)} ‚Äî ${escapeHtml(SCENARIO.mission)}</div>
      <div style="margin-top:6px; color: rgba(255,255,255,.78); line-height:1.55;">
        Niveau : <b>${escapeHtml(difficultyLabel(difficulty))}</b> ‚Ä¢ Progression : <b>${badge.pct}%</b>
      </div>
      <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
        <span class="pill">‚≠ê Score final : <b>${score}</b></span>
        <span class="pill">üò∞ Stress : <b>${stress}%</b> (${escapeHtml(stressState)})</span>
      </div>
    </div>
  `;

  optionsEl.innerHTML = `
    <div class="opt" style="cursor:default; text-align:center;">
      <div style="display:flex; justify-content:center; margin-bottom:10px;">
        <img src="${escapeHtml(badge.img)}" alt="badge" style="width:110px; height:110px; object-fit:contain; filter: drop-shadow(0 18px 35px rgba(0,0,0,.55));" />
      </div>
      <div style="font-weight:950; font-size:16px;">Badge ${escapeHtml(badge.type)}</div>
      <div style="color: rgba(255,255,255,.74); font-size:13px; margin-top:6px;">
        Enregistr√© : <b>${escapeHtml(BADGE_KEY)}</b>
      </div>
    </div>
  `;

  // buttons
  validateBtn.disabled = true;
  clearBtn.style.display = "none";
  hintBtn.disabled = true;
  pauseBtn.disabled = true;

  showKeyBtn.disabled = false;
  endBtn.style.display = "inline-block";

  endBtn.onclick = ()=>{
    ensureAudio(); sfxClick();
    window.location.href = NEXT_SCENARIO_URL;
  };

  setProgress();
  updateButtonsEnabled();
}

/* ========= START ========= */
startBtn.addEventListener("click", ()=>{
  ensureAudio(); sfxClick();

  // reset always at start
  localStorage.setItem("stress", "0");
  localStorage.setItem("score", "0");
  score = 0; stress = 0;
  setScore(0); setStress(0);

  missionErrors = 0;
  missionTimeouts = 0;

  // reset hints
  localStorage.setItem(HINT_KEY, String(RULES.hints));
  setHintsLeft(RULES.hints);

  startOverlay.style.display="none";
  idx = 0;
  attemptsForCurrentQuestion = 1;
  setAttemptsUI();

  renderQuestion(0, true);
});

/* ========= INIT ========= */
function renderStartRules(){
  startRules.innerHTML = `
    Tu vas intervenir en situation d‚Äôurgence. Tu as peu de temps pour r√©pondre.<br><br>
    <b>R√®gles (${escapeHtml(difficultyLabel(difficulty))})</b> :
    <ul style="margin:10px 0 0 18px;">
      <li><b>${RULES.seconds}s</b> par question</li>
      <li><b>${RULES.attempts}</b> tentatives maximum</li>
      <li><b>${RULES.hints}</b> indices pour tout le sc√©nario</li>
      <li><b>1 indice maximum par question</b></li>
      <li><b>√âchec mission</b> si <b>${RULES.attempts}</b> erreurs OU <b>${RULES.attempts}</b> timeouts</li>
    </ul>
    <div style="margin-top:10px;">
      Es-tu pr√™t √† commencer ?
    </div>
  `;
}

(function init(){
  locked = true;
  paused = false;
  ended = false;

  setScore(score);
  setStress(stress);

  attemptsForCurrentQuestion = 1;
  setAttemptsUI();

  setHintsLeft(hintsLeft);

  qMeta.textContent = SCENARIO.label;
  qTitle.textContent = "Pr√©pare-toi‚Ä¶";
  qDesc.innerHTML = `Tu as <b>${RULES.seconds} secondes</b> par question. Clique sur <b>D√âMARRER</b>.`;
  optionsEl.innerHTML = "";

  hudQnum.textContent = "1";
  hudTime.textContent = String(RULES.seconds);
  ring.style.setProperty("--p","100%");
  setRingProgress();

  setProgress();
  renderStartRules();
  updateButtonsEnabled();
})();
</script>
	  <script src="badge-manager.js"></script>
</body>
</html>
