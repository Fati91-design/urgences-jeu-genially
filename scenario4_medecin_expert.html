<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sc√©nario 3 ‚Äî Chute du 2e √©tage ‚Äî Interm√©diaire (M√©decin)</title>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Anton&display=swap" rel="stylesheet">

<style>
  :root{
    --glass: rgba(25,27,31,.72);
    --glass2: rgba(15,17,20,.55);

    --text: rgba(255,255,255,.93);
    --muted: rgba(255,255,255,.70);

    --gold: rgba(255,200,80,1);
    --red: rgba(255,70,70,1);
    --green: rgba(45,200,120,1);
    --blue: rgba(80,170,255,1);
    --ember: rgba(255,150,70,1);
    --ember2: rgba(255,120,50,1);
  }

  *{ box-sizing:border-box; }

  html,body{
    height:100%;
    margin:0;
    background: transparent;
    overflow:hidden; /* ‚úÖ anti-scroll Genially */
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }

  /* ===== Stage / Wrap (R√©f√©rence large) ===== */
  .stage{
    height:100vh;
    padding:10px;
    overflow:hidden;
    display:flex;
    justify-content:center;
    align-items:flex-start;
  }
  .wrap{
    width:min(1650px,100%);
    height:100%;
    display:flex;
    flex-direction:column;
    gap:12px;
    min-height:0;
  }

  /* ===== Top Tabs ===== */
  .topTabs{
    display:flex;
    gap:12px;
    align-items:center;
    flex-wrap:wrap;
    margin-bottom:2px;
  }
  .levelTab{
    display:flex;
    align-items:center;
    gap:10px;
    padding:10px 12px;
    border-radius:999px;
    background: var(--glass);
    border:1px solid rgba(255,200,150,.22);
    box-shadow: 0 12px 40px rgba(0,0,0,.35);
    backdrop-filter: blur(12px);
    position:relative;
    overflow:hidden;
  }
  .levelTab::after{
    content:"";
    position:absolute; inset:-2px;
    pointer-events:none;
    background:
      radial-gradient(360px 140px at 15% 0%, rgba(255,150,70,.18), transparent 60%),
      radial-gradient(520px 220px at 85% 120%, rgba(80,170,255,.10), transparent 60%);
    opacity:.9;
  }
  .levelDot{
    width:12px; height:12px; border-radius:999px;
    background: linear-gradient(180deg, rgba(255,176,90,1), rgba(255,120,50,1));
    box-shadow: 0 0 0 4px rgba(255,150,70,.14);
    position:relative; z-index:2;
  }
  #levelTabText{
    font-family: "Anton", system-ui, sans-serif;
    letter-spacing:.6px;
    text-transform:uppercase;
    font-size:14px;
    position:relative; z-index:2;
    white-space:nowrap;
  }

  .progressShell{
    flex:1 1 220px;
    min-width:220px;
    height:10px;
    border-radius:999px;
    background: rgba(255,255,255,.08);
    border: 1px solid rgba(255,255,255,.10);
    overflow:hidden;
    position:relative;
  }
  .progressBar{
    height:100%;
    width:0%;
    background: linear-gradient(90deg, rgba(255,176,90,1), rgba(255,120,50,1), rgba(80,170,255,1));
    transition: width .25s ease;
  }

  .miniHint{
    padding:10px 12px;
    border-radius:999px;
    background: rgba(0,0,0,.16);
    border:1px solid rgba(255,255,255,.12);
    color: rgba(255,255,255,.86);
    font-weight:900;
    font-size:12px;
    white-space:nowrap;
  }

  /* ===== HUD ===== */
  .hud{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
    margin-bottom:2px;
  }
  .hudbox{
    background: var(--glass);
    border: 1px solid rgba(255,200,150,.22);
    border-radius:18px;
    padding:14px 16px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:14px;
    position:relative;
    overflow:hidden;
    box-shadow: 0 18px 65px rgba(0,0,0,.45);
    backdrop-filter: blur(12px);
    min-height:92px;
  }
  .hudbox::after{
    content:"";
    position:absolute; inset:-2px;
    pointer-events:none;
    background:
      radial-gradient(520px 190px at 15% 0%, rgba(255,150,70,.18), transparent 60%),
      radial-gradient(620px 260px at 85% 120%, rgba(80,170,255,.10), transparent 60%);
    opacity:.9;
  }

  .profile{
    display:flex;
    align-items:center;
    gap:14px;
    min-width:0;
    position:relative;
    z-index:2;
  }
  .avatarFrame{
    width:92px; height:92px;
    border-radius:24px;
    padding:4px;
    background: linear-gradient(180deg, rgba(255,150,70,.36), rgba(80,170,255,.14));
    box-shadow: 0 18px 42px rgba(0,0,0,.45);
    flex:0 0 auto;
  }
  .avatar{
    width:100%; height:100%;
    border-radius:20px;
    border:1px solid rgba(255,255,255,.12);
    object-fit:cover;
    object-position: 50% 6%;
    transform: scale(1.35);
    transform-origin: 50% 12%;
    background: rgba(255,255,255,.06);
  }

  .ptext{ min-width:0; }
  .pname{
    font-weight:950;
    font-size:22px;
    line-height:1.05;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    text-shadow: 0 14px 30px rgba(0,0,0,.55);
  }
  .prole{
    margin-top:4px;
    font-weight:850;
    font-size:13px;
    color: var(--muted);
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }

  .chip{
    background: rgba(255,150,70,.14);
    border: 1px solid rgba(255,150,70,.20);
    border-radius:999px;
    padding:9px 12px;
    font-size:12px;
    font-weight:950;
    white-space:nowrap;
    position:relative;
    z-index:2;
  }

  .stats{
    display:flex;
    align-items:center;
    justify-content:flex-end;
    gap:10px;
    flex-wrap:wrap;
    position:relative;
    z-index:2;
  }

  .pill{
    display:flex;
    align-items:center;
    gap:10px;
    padding:10px 12px;
    border-radius:999px;
    background: rgba(255,255,255,.06);
    border: 1px solid rgba(255,255,255,.10);
    font-weight:950;
    font-size:13px;
    white-space:nowrap;
  }

  .timerPill{
    padding:8px 10px;
    gap:10px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.18);
  }

  .ring{
    width:40px; height:40px;
    border-radius:999px;
    background: conic-gradient(var(--gold) var(--p,0%), rgba(255,255,255,.14) 0);
    display:grid;
    place-items:center;
    box-shadow: 0 0 0 5px rgba(255,200,80,.14), 0 0 28px rgba(255,200,80,.10);
    transition: box-shadow .2s ease;
  }
  .ringInner{
    width:28px; height:28px;
    border-radius:999px;
    background: rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.12);
    display:grid;
    place-items:center;
    color: rgba(255,255,255,.92);
    font-size:14px;
    font-weight:950;
  }
  .timeText{ display:flex; align-items:center; gap:8px; }
  .timeText .label{ font-size:12px; font-weight:900; color: rgba(255,255,255,.75); }
  .timeText .sec{ font-size:16px; font-weight:950; }

  .timerWarn .ring{
    background: conic-gradient(var(--gold) var(--p,0%), rgba(255,255,255,.14) 0);
    box-shadow: 0 0 0 5px rgba(255,200,80,.18), 0 0 32px rgba(255,200,80,.14);
  }
  .timerDanger .ring{
    background: conic-gradient(var(--red) var(--p,0%), rgba(255,255,255,.14) 0);
    box-shadow: 0 0 0 5px rgba(255,70,70,.20), 0 0 40px rgba(255,70,70,.18);
  }

  .stressWrap{
    width:240px; height:12px;
    border-radius:999px;
    background: rgba(255,255,255,.10);
    border:1px solid rgba(255,255,255,.10);
    overflow:hidden;
  }
  .stressBar{
    height:100%;
    width:0%;
    background: linear-gradient(90deg, rgba(45,200,120,.95), rgba(255,200,80,.95), rgba(255,70,70,.95));
    transition: width .25s ease;
  }

  /* ===== Frame ===== */
  .frame{
    padding-bottom: 84px;
   
    background: var(--glass2);
    border:1px solid rgba(255,200,150,.22);
    border-radius:18px;
    padding:18px;
    position:relative;
    overflow:hidden;
    box-shadow: 0 18px 70px rgba(0,0,0,.50);
    backdrop-filter: blur(12px);
    flex:1;
    min-height:0;
  }
  .frame::after{
    content:"";
    position:absolute; inset:-2px;
    pointer-events:none;
    background:
      radial-gradient(980px 300px at 55% 0%, rgba(255,150,70,.16), transparent 60%),
      radial-gradient(900px 300px at 40% 120%, rgba(80,170,255,.10), transparent 60%);
    opacity:.9;
  }

  .qmeta{
    position:relative; z-index:2;
    color: rgba(255,255,255,.70);
    font-size:12px;
    font-weight:950;
    letter-spacing:.35px;
    text-transform:uppercase;
  }
  .qtitle{
    position:relative; z-index:2;
    margin-top:6px;
    font-weight:950;
    font-size: clamp(18px, 2.2vw, 26px);
    line-height:1.2;
    text-shadow: 0 14px 30px rgba(0,0,0,.55);
  }
  .qdesc{
    position:relative; z-index:2;
    margin-top:10px;
    color: rgba(255,255,255,.82);
    font-size:14px;
    line-height:1.5;
    max-width: 980px;
  }

  .options{
    position:relative; z-index:2;
    display:flex;
    flex-direction:column;
    gap:12px;
    margin-top:16px;
    overflow:auto;
    padding-right: 6px;
    min-height:0;
    max-height: calc(100% - 140px);
  }
  .options::-webkit-scrollbar{ width:10px; }
  .options::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.14); border-radius:999px; }
  .options::-webkit-scrollbar-track{ background: rgba(0,0,0,.12); border-radius:999px; }

  .opt{
    border-radius:14px;
    padding:13px 14px;
    font-weight:950;
    letter-spacing:.2px;
    cursor:pointer;
    user-select:none;
    transition: transform .12s ease, filter .12s ease, background .12s ease;
    border:1px solid rgba(255,255,255,.12);
    background: linear-gradient(180deg, rgba(80,170,255,.22), rgba(80,170,255,.14));
    box-shadow: 0 10px 28px rgba(0,0,0,.20);
  }
  .opt:hover{
    transform: translateY(-1px);
    filter: brightness(1.07);
    background: linear-gradient(180deg, rgba(255,150,70,.22), rgba(80,170,255,.10));
  }
  .opt:active{ transform: translateY(0px); filter: brightness(.98); }
  .opt.sel{
    background: linear-gradient(180deg, rgba(255,150,70,.30), rgba(255,120,50,.18));
    border-color: rgba(255,150,70,.30);
    box-shadow: 0 0 0 3px rgba(255,150,70,.10), 0 16px 34px rgba(0,0,0,.28);
  }

/* ‚úÖ Barre actions fixe en bas (1 seule ligne) */
.actions{
  position: fixed;
  left: 50%;
  bottom: 14px;
  transform: translateX(-50%);
  width: 100%;  /* ajuste 760/860/980 selon ton rendu */
  z-index: 25;
  padding-left:10px;
  padding-right:10px;
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: nowrap;                     /* ‚úÖ emp√™che le passage √† la ligne */
  justify-content: flex-start;           /* on g√®re l‚Äô√©cart avec margin-left:auto */

}

/* ‚úÖ Groupes gauche / droite */
.actionsLeft, .actionsRight{
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: nowrap;
  min-width: 0;
}
.actionsRight{ margin-left: auto; }      /* ‚úÖ pousse Valider/Effacer √† droite */
/* ‚úÖ Important : emp√™cher les boutons de forcer une nouvelle ligne */
.actions button{ white-space: nowrap; }

/* (si ton scroll est ailleurs, mets plut√¥t ce padding sur .wrap ou .options) */


  .btnNeo{
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.14);
    color: rgba(255,255,255,.90);
    border-radius:12px;
    padding:10px 12px;
    font-weight:950;
    letter-spacing:.2px;
  }
  .btnNeo:disabled{
    opacity:.45;
    cursor:not-allowed;
  }

  .btnPrimary{
    border:none;
    background: linear-gradient(180deg, rgba(255,176,90,1), rgba(255,120,50,1));
    color: rgba(10,12,18,.96);
    border-radius:12px;
    padding:10px 14px;
    font-weight:950;
    letter-spacing:.2px;
  }
  .btnPrimary:disabled{ opacity:.45; filter: grayscale(.2); cursor:not-allowed; }

  /* ===== Overlays ===== */
  .overlay{
    position:fixed; inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    z-index:50;
    background: rgba(0,0,0,.48);
    backdrop-filter: blur(8px);
  }
  .modalBox{
    width: min(760px, 92%);
    border-radius:18px;
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(8,10,14,.82);
    box-shadow: 0 26px 90px rgba(0,0,0,.62);
    overflow:hidden;
    position:relative;
  }
  .modalTop{
    padding:14px 16px;
    border-bottom: 1px solid rgba(255,255,255,.10);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  .modalBody{
    padding:16px;
    color: rgba(255,255,255,.92);
    line-height:1.5;
    font-size:14px;
  }
  .modalActions{
    padding:14px 16px;
    border-top: 1px solid rgba(255,255,255,.10);
    display:flex;
    justify-content:flex-end;
    gap:10px;
    flex-wrap:wrap;
  }

  .badgeState{
    font-weight:950;
    border-radius:999px;
    padding:7px 10px;
    font-size:12px;
    border: 1px solid rgba(255,255,255,.14);
    background: rgba(255,255,255,.06);
    white-space:nowrap;
  }
  .bGood{ border-color: rgba(45,200,120,.30); background: rgba(45,200,120,.12); }
  .bWarn{ border-color: rgba(255,200,80,.30); background: rgba(255,200,80,.12); }
  .bBad { border-color: rgba(255,70,70,.35); background: rgba(255,70,70,.12); }

  /* Loading overlay (r√©f√©rence) */
  .loadingBox{
    width: min(520px, 92%);
    border-radius:18px;
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.12);
    box-shadow: 0 26px 90px rgba(0,0,0,.62);
    overflow:hidden;
    position:relative;
    padding:16px;
    text-align:center;
  }
  .loadingPill{
    display:inline-flex;
    align-items:center;
    gap:10px;
    border-radius:999px;
    padding:10px 14px;
    font-weight:950;
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.12);
  }
  .spinner{
    width:18px; height:18px; border-radius:999px;
    border:2px solid rgba(255,255,255,.20);
    border-top-color: rgba(255,255,255,.85);
    animation: spin 1s linear infinite;
  }
  @keyframes spin{ to{ transform: rotate(360deg);} }

  /* Key overlay (Corrig√©) */
  .keyBox{
    width: min(980px, 95%);
    max-height: 86vh;
    overflow:auto;
    border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(8,10,14,.86);
    box-shadow: 0 26px 90px rgba(0,0,0,.66);
    position:relative;
  }
  .keyTop{
    padding:14px 16px;
    border-bottom:1px solid rgba(255,255,255,.10);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    position:sticky;
    top:0;
    background: rgba(8,10,14,.92);
    backdrop-filter: blur(10px);
    z-index:5;
  }
  .xBtn{
    border:none;
    width:40px; height:40px;
    border-radius:12px;
    background: rgba(255,255,255,.08);
    color: rgba(255,255,255,.92);
    font-weight:950;
  }
  .keyBody{ padding:16px; }

  /* Hint / Pause overlays */
  .hintTitle{ font-weight:950; font-size:18px; margin-bottom:6px; }
  .hintText{ color: rgba(255,255,255,.86); line-height:1.55; }
  .pauseTitle{ font-weight:950; font-size:18px; margin-bottom:6px; }

  /* ===== Hotspot + Image cards ===== */
  @keyframes hsPulse {
    0% { box-shadow: 0 0 0 0 rgba(255,255,255,.25); border-color: rgba(255,255,255,.55); }
    70% { box-shadow: 0 0 0 14px rgba(255,255,255,0); border-color: rgba(255,255,255,.85); }
    100% { box-shadow: 0 0 0 0 rgba(255,255,255,0); border-color: rgba(255,255,255,.55); }
  }
  .hotspot-zone{
    position:absolute;
    background: transparent !important;
    border: 2px solid rgba(255,255,255,.65);
    border-radius: 16px;
    padding:0;
    margin:0;
    cursor:pointer;
    animation: hsPulse 1.35s infinite;
  }
  .hotspot-zone.sel{
    border-color: rgba(34,197,94,.95);
    box-shadow: 0 0 0 6px rgba(34,197,94,.20);
    animation:none;
  }

  .imgGrid{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:16px;
    margin-top:12px;
  }
  .imgCard{
    border-radius:18px;
    overflow:hidden;
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.14);
    cursor:pointer;
    transition:.15s ease;
    box-shadow:0 14px 30px rgba(0,0,0,.25);
  }
  .imgCard:hover{ transform:translateY(-3px); filter:brightness(1.05); }
  .imgCard.sel{
    outline:3px solid rgba(255,165,0,.4);
    box-shadow:0 0 0 4px rgba(255,165,0,.25), 0 20px 40px rgba(0,0,0,.35);
  }
  .imgHead{
    padding:12px 16px;
    font-weight:900;
    display:flex;
    justify-content:space-between;
    background:linear-gradient(180deg, rgba(120,180,255,.25), rgba(120,180,255,.10));
  }
  .imgTag{
    width:36px; height:36px;
    border-radius:12px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    background:rgba(0,0,0,.25);
  }
  .imgPic{
    width:100%;
    height:220px;
    aspect-ratio:4/3;
    object-fit:cover;
    display:block;
  }
  .imgCap{
    padding:14px;
    text-align:center;
    font-weight:800;
  }

  /* ===== Motion ===== */
  .shake{ animation: shake .24s linear 1; }
  @keyframes shake{
    0% { transform: translateX(0px); }
    20%{ transform: translateX(-6px); }
    40%{ transform: translateX(6px); }
    60%{ transform: translateX(-4px); }
    80%{ transform: translateX(4px); }
    100%{ transform: translateX(0px); }
  }
  .pulseGood{ animation: pulseGood .32s ease 1; }
  @keyframes pulseGood{
    from{ box-shadow: 0 0 0 0 rgba(45,200,120,.0); }
    50%{ box-shadow: 0 0 0 7px rgba(45,200,120,.18); }
    to{ box-shadow: 0 0 0 0 rgba(45,200,120,.0); }
  }
  .flashBad{ animation: flashBad .30s ease 1; }
  @keyframes flashBad{
    from{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
    50%{ box-shadow: 0 0 0 7px rgba(255,70,70,.22); }
    to{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
  }
@media (max-width: 980px){
  .actions{ width: calc(100% - 18px); gap: 8px; padding: 8px 10px; }
  .btnNeo, .btnPrimary{ padding: 8px 10px; font-size: 12px; border-radius: 12px; }
}
  @media (max-width: 980px){
    .hud{ grid-template-columns:1fr; }
    .progressShell{ min-width:100%; }
    .stressWrap{ width:190px; }
    .imgGrid{ grid-template-columns:1fr; }
  }
</style>
</head>

<body>
  <div class="stage">
    <div class="wrap">

      <!-- TOP -->
      <div class="topTabs">
        <div class="levelTab">
          <div class="levelDot"></div>
          <div id="levelTabText">NIVEAU: INTERM√âDIAIRE</div>
        </div>
        <div class="progressShell" aria-label="Progression">
          <div class="progressBar" id="progressBar"></div>
        </div>
        <div class="miniHint" id="miniHint">Dur√©e 45s ‚Ä¢ 2 ‚Ä¢ 2</div>
      </div>

      <!-- HUD -->
      <div class="hud">
        <div class="hudbox">
          <div class="profile">
            <div class="avatarFrame">
              <img class="avatar" id="hudAvatar" alt="Avatar">
            </div>
            <div class="ptext">
              <div class="pname" id="hudName">Joueur</div>
              <div class="prole" id="hudRole">R√¥le: ‚Äî</div>
            </div>
          </div>
          <div class="chip" id="difficultyChip">MODE: INTERM√âDIAIRE</div>
        </div>

        <div class="hudbox">
          <div class="stats">
            <div class="pill">‚≠ê <span id="hudScore">0</span></div>
            <div class="pill">Q <span id="hudQnum">1</span>/<span id="hudQtotal">1</span></div>
            <div class="pill">üéØ Tentatives <span id="hudAttempts">0</span>/3</div>
            <div class="pill">üí° Indices <span id="hudHints">2</span>/2</div>

            <div class="pill timerPill" id="timerPill">
              <div class="ring" id="ring"><div class="ringInner">‚è±</div></div>
              <div class="timeText">
                <div class="label">Temps</div>
                <div class="sec"><span id="hudTime">45</span>s</div>
              </div>
            </div>

            <div class="stressWrap" title="Stress">
              <div class="stressBar" id="stressBar"></div>
            </div>

            <button class="btnNeo" id="hintBtn" type="button">üí° Indice</button>
            <button class="btnNeo" id="pauseBtn" type="button">‚è∏ Pause</button>
          </div>
        </div>
      </div>

      <!-- FRAME -->
      <div class="frame" id="frame">
        <div class="qmeta" id="qMeta">Sc√©nario 3 ‚Äî Chute du 2e √©tage</div>
        <div class="qtitle" id="qTitle">‚Ä¶</div>
        <div class="qdesc" id="qDesc">‚Ä¶</div>

        <div class="options" id="options"></div>

        <div class="actions">
          <div class="actionsLeft">
            <button class="btnNeo" id="showKeyBtn" type="button" disabled>üìò Corrig√©</button>
            <button class="btnPrimary" id="endBtn" type="button" style="display:none;">‚úÖ Terminer</button>
          </div>
          <div class="actionsRight">
            <button class="btnPrimary" id="validateBtn" type="button" disabled>Valider</button>
            <button class="btnNeo" id="clearBtn" type="button" style="display:none;">Effacer</button>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- START overlay -->
  <div class="overlay" id="startOverlay" style="display:flex;">
    <div class="modalBox">
      <div class="modalTop">
        <div class="badgeState bWarn">üéÆ Pr√™t ?</div>
        <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
          Mission ‚Ä¢ Chute du 2e √©tage
        </div>
      </div>
      <div class="modalBody">
        <div style="font-weight:950; font-size:22px; margin-bottom:6px;">Tu as une mission.</div>
        <div style="color: rgba(255,255,255,.82); font-size:14px; line-height:1.45;">
          Tu interviens en situation d‚Äôurgence. Tu as <b>45 secondes</b> par question et <b>3 tentatives maximum</b>.
          <br><br>
          Tu disposes de <b>2 indices pour tout le sc√©nario</b> (et <b>1 indice maximum par question</b>).
          <br><br>
          <b>Si le temps s‚Äô√©coule 2 fois ou apr√®s 3 tentatives rat√©es, tu retournes au d√©but de la mission (score = 0, stress = 0).</b>
          <br><br>
          Es-tu pr√™t(e) √† commencer ?
        </div>
      </div>
      <div class="modalActions">
        <button class="btnPrimary" id="startBtn" type="button">D√âMARRER</button>
      </div>
    </div>
  </div>

  <!-- LOADING overlay -->
  <div class="overlay" id="loadingOverlay">
    <div class="loadingBox">
      <div class="loadingPill"><span class="spinner"></span> Chargement‚Ä¶</div>
      <div style="margin-top:10px; color: rgba(255,255,255,.72); font-size:12px; font-weight:900;">
        Pr√©paration de la prochaine situation‚Ä¶
      </div>
    </div>
  </div>

  <!-- FEEDBACK overlay -->
  <div class="overlay" id="feedbackOverlay">
    <div class="modalBox" id="feedbackBox">
      <div class="modalTop">
        <div class="badgeState" id="badgeState">‚Äî</div>
        <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
          Score: <span id="modalScore">0</span> ‚Ä¢ Stress: <span id="modalStress">0</span>%
        </div>
      </div>
      <div class="modalBody" id="modalText">‚Ä¶</div>
      <div class="modalActions">
        <button class="btnNeo" id="retryBtn" type="button">R√©essayer</button>
        <button class="btnPrimary" id="nextBtn" type="button">Suivant</button>
        <button class="btnPrimary" id="okBtn" type="button" style="display:none;">OK</button>
      </div>
    </div>
  </div>

  <!-- HINT overlay -->
  <div class="overlay" id="hintOverlay">
    <div class="modalBox">
      <div class="modalTop">
        <div class="badgeState bWarn">üí° Indice</div>
        <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
          Indices restants : <span id="hintLeftText">0</span>/2
        </div>
      </div>
      <div class="modalBody">
        <div class="hintTitle">Voici ton indice</div>
        <div class="hintText" id="hintText">‚Ä¶</div>
      </div>
      <div class="modalActions">
        <button class="btnPrimary" id="hintCloseBtn" type="button">Reprendre</button>
      </div>
    </div>
  </div>

  <!-- PAUSE overlay -->
  <div class="overlay" id="pauseOverlay">
    <div class="modalBox">
      <div class="modalTop">
        <div class="badgeState bWarn">‚è∏ Pause</div>
        <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
          Temps fig√©
        </div>
      </div>
      <div class="modalBody">
        <div class="pauseTitle">Pause activ√©e</div>
        <div style="color: rgba(255,255,255,.82); line-height:1.55;">
          Clique sur <b>Reprendre</b> quand tu es pr√™t(e).
        </div>
      </div>
      <div class="modalActions">
        <button class="btnPrimary" id="resumeBtn" type="button">Reprendre</button>
      </div>
    </div>
  </div>

  <!-- KEY overlay -->
  <div class="overlay" id="keyOverlay">
    <div class="keyBox">
      <div class="keyTop">
        <div class="badgeState bGood">üìò Corrig√©</div>
        <button class="xBtn" id="closeKeyBtn" type="button">‚úñ</button>
      </div>
      <div class="keyBody" id="keyBody"></div>
    </div>
  </div>

<script>
/* ========= SFX (r√©f√©rence) ========= */
let audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
function tone(freq, dur=0.08, type="sine", gain=0.05){
  ensureAudio();
  const t0 = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type; osc.frequency.value = freq;
  g.gain.value = gain;
  osc.connect(g); g.connect(audioCtx.destination);
  osc.start(t0); osc.stop(t0 + dur);
}
function sfxClick(){ tone(520,0.04,"triangle",0.035); }
function sfxCorrect(){ tone(660,0.07,"sine",0.06); setTimeout(()=>tone(880,0.08,"sine",0.06), 80); }
function sfxWrong(){ tone(220,0.10,"square",0.05); setTimeout(()=>tone(180,0.12,"square",0.05), 90); }
function sfxCritical(){ tone(140,0.14,"sawtooth",0.05); setTimeout(()=>tone(120,0.16,"sawtooth",0.05), 120); }
function sfxAlarmLong(){
  ensureAudio();
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = "sawtooth";
  osc.frequency.setValueAtTime(520, now);
  osc.frequency.linearRampToValueAtTime(380, now + 0.35);
  osc.frequency.linearRampToValueAtTime(520, now + 0.70);
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(0.07, now + 0.02);
  g.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
  osc.connect(g); g.connect(audioCtx.destination);
  osc.start(now); osc.stop(now + 1.25);
}
function sfxVictory(){
  ensureAudio();
  const notes = [
    {f:659,d:0.10},{f:784,d:0.10},{f:988,d:0.14},
    {f:1175,d:0.18},{f:988,d:0.14},{f:1047,d:0.22}
  ];
  let t = 0;
  notes.forEach((n)=>{
    setTimeout(()=>tone(n.f, n.d, "sine", 0.065), t*1000);
    t += n.d + 0.03;
  });
}

/* ========= Helpers ========= */
const el = (id)=>document.getElementById(id);
const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
const escapeHtml=(s)=>String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
function normalize(s){ return String(s||"").trim().toLowerCase(); }

/* ========= UI refs ========= */
const levelTabText = el("levelTabText");
const progressBar = el("progressBar");
const miniHint = el("miniHint");

const hudName = el("hudName");
const hudRole = el("hudRole");
const hudAvatar = el("hudAvatar");
const difficultyChip = el("difficultyChip");
const hudScore = el("hudScore");
const hudQnum = el("hudQnum");
const hudQtotal = el("hudQtotal");
const hudAttempts = el("hudAttempts");
const hudHints = el("hudHints");
const hudTime = el("hudTime");
const ring = el("ring");
const timerPill = el("timerPill");
const stressBar = el("stressBar");

const qMeta = el("qMeta");
const qTitle = el("qTitle");
const qDesc  = el("qDesc");
const optionsEl = el("options");

const hintBtn = el("hintBtn");
const pauseBtn = el("pauseBtn");
const validateBtn = el("validateBtn");
const clearBtn = el("clearBtn");
const showKeyBtn = el("showKeyBtn");
const endBtn = el("endBtn");
const frame = el("frame");

/* overlays */
const startOverlay = el("startOverlay");
const startBtn = el("startBtn");
const loadingOverlay = el("loadingOverlay");

const feedbackOverlay = el("feedbackOverlay");
const feedbackBox = el("feedbackBox");
const badgeState = el("badgeState");
const modalText = el("modalText");
const modalScore = el("modalScore");
const modalStress = el("modalStress");
const retryBtn = el("retryBtn");
const nextBtn  = el("nextBtn");
const okBtn    = el("okBtn");

const hintOverlay = el("hintOverlay");
const hintLeftText = el("hintLeftText");
const hintText = el("hintText");
const hintCloseBtn = el("hintCloseBtn");

const pauseOverlay = el("pauseOverlay");
const resumeBtn = el("resumeBtn");

const keyOverlay = el("keyOverlay");
const keyBody = el("keyBody");
const closeKeyBtn = el("closeKeyBtn");

/* ========= CONFIG (r√©f√©rence) ========= */
const SCENARIO = {
  id: 3,
  label: "Sc√©nario 3 ‚Äî Chute du 2e √©tage",
  mission: "Chute du 2e √©tage",
  level: "Interm√©diaire"
};
const NEXT_SCENARIO_URL = "#"; // ‚úÖ remplace par ton lien Genially
const TIMER_SECONDS = 45;
const ATTEMPTS_MAX = 3;
const HINT_MAX = 2;
const HINT_KEY = `hints_left_s${SCENARIO.id}`;
const STRESS_RULES = { wrong:10, timeout:15, critical:25 };

/* ========= Player / role ========= */
const role = "medecin";
const roleLabelMap = { medecin:"M√©decin", infirmier:"Infirmier", pompier:"Pompier" };
const playerName =
  window.player_name || window.playerName ||
  localStorage.getItem("player_name") || localStorage.getItem("playerName") ||
  "Joueur";
const avatarFile = localStorage.getItem("avatar") || "medecin_f.png";
const difficulty = "interm√©diaire";

hudName.textContent = playerName;
hudRole.textContent = "R√¥le: " + (roleLabelMap[role] || "‚Äî");
hudAvatar.src = "assets/avatars/" + avatarFile;
difficultyChip.textContent = "MODE: INTERM√âDIAIRE";
levelTabText.textContent = "NIVEAU: INTERM√âDIAIRE";
miniHint.textContent = `Dur√©e ${TIMER_SECONDS}s ‚Ä¢ Tentatives ${ATTEMPTS_MAX} ‚Ä¢ Indices ${HINT_MAX}`;

qMeta.textContent = SCENARIO.label + " ‚Ä¢ " + SCENARIO.level;

/* ========= Questions (PRISES DU CODE DESSOUS) ========= */
const questions = [{"type":"multi","title":"Red flags neuro","desc":"Coche les signes neuro inqui√©tants :","options":[{"text":"Vomissements r√©p√©t√©s","correct":true},{"text":"GCS qui baisse / confusion","correct":true},{"text":"Douleur au poignet isol√©e","correct":false},{"text":"Faiblesse d‚Äôun membre","correct":true}],"okFb":"‚úÖ Bon rep√©rage des urgences neuro.","badFb":"‚ùå Revois les signes neuro."},{"type":"single","title":"Anticoagulants","desc":"Si le patient prend un anticoagulant, le risque principal est :","options":[{"text":"H√©morragie interne plus probable","kind":"ok","fb":"‚úÖ Oui."},{"text":"Sans cons√©quence","kind":"wrong","fb":"‚ùå Faux."},{"text":"Moins grave","kind":"wrong","fb":"‚ùå Faux."},{"text":"Uniquement douleur","kind":"wrong","fb":"‚ùå Faux."}]},{"type":"tf","title":"Rachis cervical","desc":"Vrai/Faux : douleur cervicale apr√®s chute = immobilisation stricte.","tf":{"trueOpt":{"kind":"ok","fb":"‚úÖ Vrai."},"falseOpt":{"kind":"wrong","fb":"‚ùå Faux."}}},{"type":"image_single","title":"D√©cision m√©dicale imm√©diate","desc":"Choisis l‚Äôimage qui correspond √† la conduite la plus adapt√©e imm√©diatement apr√®s la chute :","options":[{"label":"A","imgSrc":"assets/chute_q4_a.png","caption":"Immobilisation axe t√™te-cou-tronc","kind":"ok","fb":"‚úÖ Correct : conduite la plus s√ªre apr√®s chute de hauteur."},{"label":"B","imgSrc":"assets/chute_q4_b.png","caption":"Victime assise / mobilis√©e","kind":"wrong","fb":"‚ùå Non : mobilisation dangereuse."},{"label":"C","imgSrc":"assets/chute_q4_c.png","caption":"Maintien t√™te-cou + √©valuation respiration + alerte/O‚ÇÇ","kind":"wrong","fb":"üü° Tr√®s bien aussi, mais ici on attend surtout l‚Äôimmobilisation stricte."}]},{"type":"single","title":"Priorit√© vitale","desc":"Victime tr√®s p√¢le : param√®tre vital prioritaire :","options":[{"text":"Temp√©rature","kind":"wrong","fb":"‚ùå Non."},{"text":"Respiration","kind":"ok","fb":"‚úÖ Priorit√© vitale."},{"text":"Douleur","kind":"wrong","fb":"‚ùå Non."},{"text":"Glyc√©mie","kind":"wrong","fb":"‚ùå Non."}]},{"type":"short","title":"GCS max","desc":"Score maximal Glasgow (1 nombre)","answers":["15"],"okFb":"‚úÖ 15.","badFb":"‚ùå 15."},{"type":"cloze","title":"Compl√©ter","desc":"Compl√®te 2 lettres :","template":"Transmission : <b>{blank1}</b>IST et MI<b>{blank2}</b>T.","blanks":[{"key":"blank1","answer":"m"},{"key":"blank2","answer":"s"}],"okFb":"‚úÖ MIST.","badFb":"‚ùå m et s."},{"type":"drag_order","title":"ABCDE","desc":"Mets l‚Äôordre :","items":[{"id":"a","text":"A: Airway + immobilisation cervicale"},{"id":"b","text":"B: Breathing (FR, O‚ÇÇ si dispo)"},{"id":"c","text":"C: Circulation (pouls, choc, h√©morragie)"},{"id":"d","text":"D: Disability (neuro, GCS)"},{"id":"e","text":"E: Exposure (hypothermie, examen complet)"}],"expected":["a","b","c","d","e"],"okFb":"‚úÖ ABCDE correct.","badFb":"‚ùå Ordre ABCDE attendu."},{"type":"hotspot","gate":true,"title":"Hotspot ‚Äî Zone critique","desc":"","imgSrc":"scenario_3_hotspot.png","hotspots":[{"label":"ok","x":30,"y":28,"w":18,"h":40,"kind":"ok","fb":"‚úÖ Correct : rachis/colonne (ne pas mobiliser).","pts":10},{"label":"ko","x":8,"y":22,"w":18,"h":22,"kind":"wrong","fb":"‚ùå Non : pas la priorit√© traumatique ici.","pts":-2},{"label":"ko","x":68,"y":70,"w":20,"h":20,"kind":"wrong","fb":"‚ùå Non : pas la priorit√© traumatique ici.","pts":-2}]},{"type":"multi","title":"Stabilisation","desc":"Mesures imm√©diates :","options":[{"text":"Couvrir / isoler du sol","correct":true},{"text":"O‚ÇÇ si d√©tresse respiratoire","correct":true},{"text":"Surveillance r√©p√©t√©e (GCS/FR)","correct":true},{"text":"Sur√©lever jambes malgr√© suspicion rachis","correct":false}],"okFb":"‚úÖ Bon plan de stabilisation.","badFb":"‚ùå Attention √† la manipulation."},{"type":"single","title":"Erreur critique","desc":"Erreur critique :","options":[{"text":"Faire marcher la victime","kind":"ok","fb":"üö® Critique : risque aggravation."},{"text":"Rassurer","kind":"wrong","fb":"‚úÖ OK."},{"text":"Surveiller FR","kind":"wrong","fb":"‚úÖ OK."},{"text":"Couvrir","kind":"wrong","fb":"‚úÖ OK."}]},{"type":"tf","title":"O‚ÇÇ","desc":"Vrai/Faux : O‚ÇÇ si SpO‚ÇÇ basse ou d√©tresse.","tf":{"trueOpt":{"kind":"ok","fb":"‚úÖ Vrai."},"falseOpt":{"kind":"wrong","fb":"‚ùå Faux."}}},{"type":"short","title":"Urgence","desc":"Num√©ro m√©dical (1 nombre)","answers":["15"],"okFb":"‚úÖ 15.","badFb":"‚ùå 15."},{"type":"short","title":"Mot-cl√©","desc":"Structure √† prot√©ger (1 mot)","answers":["rachis","colonne"],"okFb":"‚úÖ rachis.","badFb":"‚ùå rachis."},{"type":"tf","title":"R√©-alerte","desc":"Vrai/Faux : baisse de conscience ‚Üí r√©-alerte imm√©diate.","tf":{"trueOpt":{"kind":"ok","fb":"‚úÖ Vrai."},"falseOpt":{"kind":"wrong","fb":"‚ùå Faux."}}}];

const TOTAL = questions.length;
hudQtotal.textContent = String(TOTAL);

/* ========= Score / Stress / Hints ========= */
let score = parseInt(localStorage.getItem("score") || "0", 10);
let stress = parseInt(localStorage.getItem("stress") || "0", 10);
if(isNaN(score)) score = 0;
if(isNaN(stress)) stress = 0;

let hintsLeft = parseInt(localStorage.getItem(HINT_KEY) || String(HINT_MAX), 10);
if(isNaN(hintsLeft)) hintsLeft = HINT_MAX;
hintsLeft = clamp(hintsLeft, 0, HINT_MAX);
localStorage.setItem(HINT_KEY, String(hintsLeft));

function setScore(v){
  score = v;
  localStorage.setItem("score", String(score));
  hudScore.textContent = String(score);
  modalScore.textContent = String(score);
}
function addScore(d){ setScore(score + d); }

function setStress(v){
  stress = clamp(v, 0, 100);
  localStorage.setItem("stress", String(stress));
  stressBar.style.width = stress + "%";
  modalStress.textContent = String(stress);
}
function addStress(d){ setStress(stress + d); }

function setHintsUI(){
  hudHints.textContent = String(hintsLeft);
  hintLeftText.textContent = String(hintsLeft);
  // miniHint (r√©f√©rence) reste constant, mais HUD refl√®te le compteur
}
setScore(score);
setStress(stress);
setHintsUI();

/* ========= Progress ========= */
function setProgress(){
  const p = clamp(Math.round(((idx) / TOTAL) * 100), 0, 100);
  progressBar.style.width = p + "%";
}

/* ========= Timer / Attempts ========= */
let idx = 0;
let attemptsUsed = 0;             // 0..ATTEMPTS_MAX
let hintUsedThisQuestion = false; // 1 indice max par question
let locked = true;
let paused = false;

let timerId = null;
let timeLeft = TIMER_SECONDS;

function setAttemptsUI(){
  hudAttempts.textContent = String(attemptsUsed);
}
function setRingProgress(){
  const p = clamp(Math.round((timeLeft / TIMER_SECONDS) * 100), 0, 100);
  ring.style.setProperty("--p", p + "%");
  timerPill.classList.remove("timerWarn","timerDanger");
  if(timeLeft <= 5) timerPill.classList.add("timerDanger");
  else if(timeLeft <= 10) timerPill.classList.add("timerWarn");
}
function stopTimer(){ clearInterval(timerId); timerId=null; }
function startTimer(){
  stopTimer();
  timeLeft = TIMER_SECONDS;
  hudTime.textContent = String(timeLeft);
  setRingProgress();

  timerId = setInterval(()=>{
    if(locked || paused) return;
    timeLeft--;
    hudTime.textContent = String(timeLeft);
    setRingProgress();
    if(timeLeft <= 0){
      stopTimer();
      sfxAlarmLong();
      addStress(STRESS_RULES.timeout);
      onAttemptFail("‚è±Ô∏è Temps √©coul√©.");
    }
  }, 1000);
}

/* ========= Loading transition (r√©f√©rence) ========= */
function showLoading(ms=800){
  loadingOverlay.style.display = "flex";
  return new Promise(res=>{
    setTimeout(()=>{
      loadingOverlay.style.display = "none";
      res();
    }, ms);
  });
}

/* ========= Selection State ========= */
let selectedSingle = null;
let multiSelected = new Set();
let inputValue = "";
let clozeValues = {};
function resetState(){
  selectedSingle = null;
  multiSelected.clear();
  inputValue = "";
  clozeValues = {};
  validateBtn.disabled = true;
}

/* ========= Render helpers ========= */
function mkOpt(text){
  const d = document.createElement("div");
  d.className = "opt";
  d.textContent = text;
  return d;
}

/* ========= Hints (r√®gles: 2 total, 1 par question) ========= */
function computeHintForQuestion(q){
  // ‚úÖ Indices ‚Äúintelligents‚Äù sans changer tes questions : on donne un guidage vers la r√©ponse
  if(q.type==="tf") return "Relis la phrase : si tu suspectes un danger (rachis / d√©tresse), la r√©ponse est souvent la conduite la plus prudente.";
  if(q.type==="short"){
    return "Indice : c‚Äôest une valeur standard connue en urgence (un nombre court).";
  }
  if(q.type==="cloze"){
    return "Indice : c‚Äôest un acronyme de transmission (4 lettres) et tu dois compl√©ter les lettres manquantes.";
  }
  if(q.type==="drag_order"){
    return "Indice : c‚Äôest l‚Äôordre universel d‚Äô√©valuation en traumato (A ‚Üí B ‚Üí C ‚Üí D ‚Üí E).";
  }
  if(q.type==="image_single"){
    return "Indice : apr√®s une chute de hauteur, priorit√© √† la s√©curit√© du rachis et √† l‚Äôimmobilisation.";
  }
  if(q.type==="hotspot"){
    return "Indice : cherche la zone la plus critique en traumatisme (structure √† prot√©ger / immobiliser).";
  }
  if(q.type==="multi"){
    return "Indice : coche uniquement les signes qui indiquent une atteinte grave (danger imm√©diat).";
  }
  if(q.type==="single"){
    return "Indice : choisis l‚Äôoption qui augmente le risque ou correspond √† une priorit√© vitale.";
  }
  return "Indice : choisis la conduite la plus s√ªre.";
}

function refreshHintBtn(){
  hintBtn.disabled = locked || paused || (hintsLeft<=0) || hintUsedThisQuestion;
  hintBtn.textContent = hintUsedThisQuestion ? "üí° Indice (utilis√©)" : "üí° Indice";
}

hintBtn.addEventListener("click", ()=>{
  if(hintBtn.disabled) return;
  ensureAudio(); sfxClick();

  hintsLeft = clamp(hintsLeft - 1, 0, HINT_MAX);
  localStorage.setItem(HINT_KEY, String(hintsLeft));
  setHintsUI();

  hintUsedThisQuestion = true;
  refreshHintBtn();

  paused = true;
  hintText.innerHTML = escapeHtml(computeHintForQuestion(questions[idx]));
  hintLeftText.textContent = String(hintsLeft);
  hintOverlay.style.display = "flex";
});

hintCloseBtn.addEventListener("click", ()=>{
  ensureAudio(); sfxClick();
  hintOverlay.style.display = "none";
  paused = false;
});

/* ========= Pause ========= */
pauseBtn.addEventListener("click", ()=>{
  if(locked) return;
  ensureAudio(); sfxClick();
  paused = true;
  pauseOverlay.style.display = "flex";
  refreshHintBtn();
});
resumeBtn.addEventListener("click", ()=>{
  ensureAudio(); sfxClick();
  pauseOverlay.style.display = "none";
  paused = false;
  refreshHintBtn();
});

/* ========= Feedback overlay ========= */
function motion(type){
  frame.classList.remove("shake","pulseGood","flashBad");
  feedbackBox.classList.remove("shake","pulseGood","flashBad");
  if(type==="good"){ frame.classList.add("pulseGood"); }
  else if(type==="wrong"){ feedbackBox.classList.add("shake"); }
  else if(type==="critical"){ feedbackBox.classList.add("shake"); frame.classList.add("flashBad"); }
}

function showFeedback(kind, text, {allowRetry, allowNext, missionFail}){
  badgeState.className = "badgeState";
  if(kind==="good"){ badgeState.classList.add("bGood"); badgeState.textContent="‚úÖ Bonne r√©ponse"; }
  if(kind==="warn"){ badgeState.classList.add("bWarn"); badgeState.textContent="‚ö†Ô∏è √Ä corriger"; }
  if(kind==="bad") { badgeState.classList.add("bBad");  badgeState.textContent="üö® Mission √©chou√©e"; }

  modalText.textContent = text;
  feedbackOverlay.style.display = "flex";

  retryBtn.style.display = allowRetry ? "inline-block" : "none";
  nextBtn.style.display  = allowNext  ? "inline-block" : "none";
  okBtn.style.display    = missionFail ? "inline-block" : "none";
  okBtn.textContent      = missionFail ? "OK" : "OK";

  retryBtn.onclick = ()=>{
    ensureAudio(); sfxClick();
    feedbackOverlay.style.display="none";
    locked = false;
    paused = false;
    refreshHintBtn();
    startTimer();
  };

  nextBtn.onclick = async ()=>{
    ensureAudio(); sfxClick();
    feedbackOverlay.style.display="none";
    idx++;
    if(idx < TOTAL){
      await showLoading(800);
      renderQuestion(idx, true);
    }else{
      endScenario();
    }
  };

  okBtn.onclick = ()=>{
    ensureAudio(); sfxClick();
    feedbackOverlay.style.display="none";
    resetMission(true);
  };
}

function hideFeedback(){ feedbackOverlay.style.display="none"; }

/* ========= Mission Fail / Reset ========= */
function missionFail(message){
  stopTimer();
  locked = true;
  paused = false;
  refreshHintBtn();
  showFeedback("bad", message, {allowRetry:false, allowNext:false, missionFail:true});
  motion("critical");
}

function resetMission(showStart=true){
  stopTimer();
  idx = 0;
  attemptsUsed = 0;
  hintUsedThisQuestion = false;

  setScore(0);
  setStress(0);

  locked = true;
  paused = false;

  // ‚úÖ R√©initialiser les indices (interm√©diaire: 2) au red√©marrage (r√©f√©rence interm√©diaire)
  hintsLeft = HINT_MAX;
  localStorage.setItem(HINT_KEY, String(hintsLeft));
  setHintsUI();

  if(showStart) startOverlay.style.display="flex";
}

/* ========= Attempts logic (2 tentatives max) ========= */
function onAttemptFail(baseMsg){
  attemptsUsed++;
  setAttemptsUI();

  if(attemptsUsed >= ATTEMPTS_MAX){
    sfxAlarmLong();
    missionFail(`‚ùå ${ATTEMPTS_MAX} tentatives/temps √©coul√©. Mission √©chou√©e. Retour au d√©part‚Ä¶ (score remis √† z√©ro)`);
    return;
  }
  // tentative restante ‚Üí propose r√©essai
  showFeedback("warn", `${baseMsg} (Tentative ${attemptsUsed}/${ATTEMPTS_MAX})`, {allowRetry:true, allowNext:false, missionFail:false});
}

function evaluateOption(opt){
  if(opt.kind==="ok"){
    addScore(opt.pts ?? 10);
    sfxCorrect();
    motion("good");
    showFeedback("good", opt.fb || "‚úÖ Correct.", {allowRetry:false, allowNext:true, missionFail:false});
    return;
  }
  if(opt.kind==="critical"){
    addStress(STRESS_RULES.critical);
    addScore(opt.pts ?? -10);
    sfxCritical();
    motion("critical");
    onAttemptFail(opt.fb || "üö® Erreur critique.");
    return;
  }
  if(opt.kind==="partial"){
    addStress(STRESS_RULES.wrong);
    addScore(opt.pts ?? 3);
    sfxWrong();
    motion("wrong");
    onAttemptFail(opt.fb || "üü° Partiel.");
    return;
  }
  addStress(STRESS_RULES.wrong);
  sfxWrong();
  motion("wrong");
  onAttemptFail(opt.fb || "‚ùå Incorrect.");
}

/* ========= Render Question ========= */
function renderQuestion(i, resetAttempts=true){
  locked = false;
  paused = false;

  stopTimer();
  hideFeedback();

  if(resetAttempts){
    attemptsUsed = 0;
    hintUsedThisQuestion = false;
  }
  setAttemptsUI();

  resetState();
  refreshHintBtn();
  setProgress();

  const q = questions[i];
  qMeta.textContent = `${SCENARIO.label} ‚Ä¢ ${SCENARIO.level}`;
  qTitle.textContent = q.title || "‚Äî";
  qDesc.innerHTML = q.desc || "";
  optionsEl.innerHTML = "";
  clearBtn.style.display = "none";
  validateBtn.disabled = true;

  const type = q.type;

  if(type==="single"){
    q.options.forEach((opt, oi)=>{
      const d = mkOpt(opt.text);
      d.onclick=()=>{
        ensureAudio(); sfxClick();
        [...optionsEl.children].forEach(x=>x.classList.remove("sel"));
        d.classList.add("sel");
        selectedSingle = oi;
        validateBtn.disabled = false;
      };
      optionsEl.appendChild(d);
    });
  }

  if(type==="tf"){
    const opts=[{label:"Vrai", data:q.tf.trueOpt},{label:"Faux", data:q.tf.falseOpt}];
    opts.forEach((o, oi)=>{
      const d = mkOpt(o.label);
      d.onclick=()=>{
        ensureAudio(); sfxClick();
        [...optionsEl.children].forEach(x=>x.classList.remove("sel"));
        d.classList.add("sel");
        selectedSingle = oi;
        validateBtn.disabled = false;
      };
      optionsEl.appendChild(d);
    });
  }

  if(type==="multi"){
    clearBtn.style.display="inline-block";
    q.options.forEach((opt, oi)=>{
      const d = mkOpt(opt.text);
      d.onclick=()=>{
        ensureAudio(); sfxClick();
        if(multiSelected.has(oi)){ multiSelected.delete(oi); d.classList.remove("sel"); }
        else { multiSelected.add(oi); d.classList.add("sel"); }
        validateBtn.disabled = (multiSelected.size===0);
      };
      optionsEl.appendChild(d);
    });
  }

  if(type==="short"){
    clearBtn.style.display="inline-block";
    const box = document.createElement("div");
    box.className="opt"; box.style.cursor="default";
    box.innerHTML = `
      <div style="font-weight:950; margin-bottom:8px;">Ta r√©ponse</div>
      <input id="shortInput" class="form-control" type="text" placeholder="√âcris ici‚Ä¶"
        style="background: rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.18); color: rgba(255,255,255,.92);" />
      <div style="margin-top:8px; font-size:12px; color: rgba(255,255,255,.72);">Astuce : une valeur courte suffit.</div>
    `;
    optionsEl.appendChild(box);
    const inp = box.querySelector("#shortInput");
    inp.addEventListener("input", ()=>{
      inputValue = inp.value;
      validateBtn.disabled = (inp.value.trim().length===0);
    });
  }

  if(type==="cloze"){
    clearBtn.style.display="inline-block";
    const box = document.createElement("div");
    box.className="opt"; box.style.cursor="default";

    const html = (q.template||"")
      .replace("{blank1}", `<input data-k="blank1" class="form-control"
        style="display:inline-block; width:240px; margin:0 6px; background: rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.18); color: rgba(255,255,255,.92);" placeholder="..." />`)
      .replace("{blank2}", `<input data-k="blank2" class="form-control"
        style="display:inline-block; width:260px; margin:0 6px; background: rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.18); color: rgba(255,255,255,.92);" placeholder="..." />`);

    box.innerHTML = `
      <div style="line-height:1.8;">${html}</div>
      <div style="margin-top:8px; font-size:12px; color: rgba(255,255,255,.72);">Astuce : √©cris seulement les lettres.</div>
    `;
    optionsEl.appendChild(box);

    const inputs = box.querySelectorAll("input[data-k]");
    inputs.forEach(inp=>{
      inp.addEventListener("input", ()=>{
        clozeValues[inp.dataset.k] = inp.value;
        const filled = (q.blanks||[]).every(b => (clozeValues[b.key]||"").trim().length>0);
        validateBtn.disabled = !filled;
      });
    });
  }

  if(type==="drag_order"){
    clearBtn.style.display="inline-block";
    const note = document.createElement("div");
    note.className="pill";
    note.style.marginBottom="10px";
    note.textContent="üñ±Ô∏è Glisse-d√©pose les cartes pour les mettre dans l‚Äôordre.";
    optionsEl.appendChild(note);

    const list = document.createElement("div");
    list.id="dragList";
    list.style.display="grid";
    list.style.gap="10px";

    const items = [...(q.items||[])];
    for(let k=items.length-1;k>0;k--){
      const j=Math.floor(Math.random()*(k+1));
      [items[k],items[j]]=[items[j],items[k]];
    }

    items.forEach((it)=>{
      const row = document.createElement("div");
      row.className="opt";
      row.setAttribute("draggable","true");
      row.dataset.id = it.id;
      row.innerHTML = `
        <div style="font-weight:950;">${escapeHtml(it.text)}</div>
        <div style="font-size:12px; color: rgba(255,255,255,.68); margin-top:3px;">(glisser)</div>
      `;
      list.appendChild(row);
    });

    optionsEl.appendChild(list);

    let dragSrc = null;
    list.addEventListener("dragstart",(e)=>{
      const target = e.target.closest("[draggable='true']");
      if(!target) return;
      dragSrc = target;
      e.dataTransfer.effectAllowed="move";
      target.style.opacity="0.6";
      validateBtn.disabled = false;
    });
    list.addEventListener("dragend",(e)=>{
      const target = e.target.closest("[draggable='true']");
      if(target) target.style.opacity="1";
      dragSrc=null;
    });
    list.addEventListener("dragover",(e)=>{
      e.preventDefault();
      const over = e.target.closest("[draggable='true']");
      if(!over || !dragSrc || over===dragSrc) return;
      const rect = over.getBoundingClientRect();
      const before = (e.clientY - rect.top) < rect.height/2;
      list.insertBefore(dragSrc, before ? over : over.nextSibling);
    });
    list.addEventListener("drop",(e)=>{
      e.preventDefault();
      validateBtn.disabled = false;
    });
  }

  if(type==="image_single"){
    const grid = document.createElement("div");
    grid.className = "imgGrid";

    q.options.forEach((opt, oi)=>{
      const card = document.createElement("div");
      card.className = "imgCard";
      card.innerHTML = `
        <div class="imgHead">
          <div>Option ${escapeHtml(opt.label||String(oi+1))}</div>
          <div class="imgTag">${escapeHtml(opt.label||String(oi+1))}</div>
        </div>
        <img class="imgPic" src="${opt.imgSrc}" alt="Option ${escapeHtml(opt.label||String(oi+1))}">
        <div class="imgCap">${escapeHtml(opt.caption||"")}</div>
      `;
      card.onclick = ()=>{
        ensureAudio(); sfxClick();
        [...grid.querySelectorAll(".imgCard")].forEach(c=>c.classList.remove("sel"));
        card.classList.add("sel");
        selectedSingle = oi;
        validateBtn.disabled = false;
      };
      grid.appendChild(card);
    });

    optionsEl.appendChild(grid);
  }

  if(type==="hotspot"){
    clearBtn.style.display="inline-block";

    const msg = document.createElement("div");
    msg.className="pill";
    msg.style.marginBottom="10px";
    msg.innerHTML = "üéØ <b>Clique sur la zone correcte</b> sur l‚Äôimage, puis appuie sur <b>Valider</b>.";
    optionsEl.appendChild(msg);

    const wrap = document.createElement("div");
    wrap.style.position="relative";
    wrap.style.width="100%";
    wrap.style.maxWidth="760px";
    wrap.style.margin="0 auto";
    wrap.style.borderRadius="18px";
    wrap.style.overflow="hidden";
    wrap.style.border="1px solid rgba(255,255,255,.14)";
    wrap.style.background="rgba(0,0,0,.18)";

    wrap.innerHTML = `<img src="${q.imgSrc||""}" alt="hotspot" style="width:100%; height:240px; display:block;">`;
    optionsEl.appendChild(wrap);

    const zones = document.createElement("div");
    zones.style.position="absolute";
    zones.style.inset="0";
    zones.style.pointerEvents="auto";
    wrap.appendChild(zones);

    selectedSingle = null;
    validateBtn.disabled = false; // le joueur peut valider apr√®s s√©lection, mais on laisse le bouton actif
    (q.hotspots||[]).forEach((h, hi)=>{
      const z = document.createElement("button");
      z.type="button";
      z.className="hotspot-zone";
      z.style.left = h.x + "%";
      z.style.top  = h.y + "%";
      z.style.width = h.w + "%";
      z.style.height= h.h + "%";
      z.style.borderRadius = (h.r||16) + "px";
      z.onclick = ()=>{
        ensureAudio(); sfxClick();
        [...zones.querySelectorAll("button")].forEach(b=>b.classList.remove("sel"));
        z.classList.add("sel");
        selectedSingle = hi;
        validateBtn.disabled = false;
      };
      zones.appendChild(z);
    });
  }

  hudQnum.textContent = String(i+1);
  refreshHintBtn();
  startTimer();
}

/* ========= Clear ========= */
clearBtn.addEventListener("click", ()=>{
  ensureAudio(); sfxClick();
  renderQuestion(idx, false);
});

/* ========= Validate ========= */
validateBtn.addEventListener("click", ()=>{
  if(locked) return;
  const q = questions[idx];
  const type = q.type;

  // garde-fous (ne pas p√©naliser si vide)
  function needSelection(msg){
    ensureAudio(); sfxClick();
    showFeedback("warn", msg, {allowRetry:false, allowNext:false, missionFail:false});
    retryBtn.style.display="none";
    nextBtn.style.display="none";
    okBtn.style.display="inline-block";
    okBtn.textContent="OK";
    okBtn.onclick = ()=>{
      ensureAudio(); sfxClick();
      hideFeedback();
      locked=false;
      paused=false;
      refreshHintBtn();
      startTimer();
    };
  }

  if(type==="single" || type==="tf" || type==="image_single" || type==="hotspot"){
    if(selectedSingle===null){ needSelection("Choisis une r√©ponse avant de valider."); return; }
  }
  if(type==="multi"){
    if(multiSelected.size===0){ needSelection("S√©lectionne au moins une proposition avant de valider."); return; }
  }
  if(type==="short"){
    if((inputValue||"").trim().length===0){ needSelection("√âcris une r√©ponse avant de valider."); return; }
  }
  if(type==="cloze"){
    const filled = (q.blanks||[]).every(b => (clozeValues[b.key]||"").trim().length>0);
    if(!filled){ needSelection("Compl√®te tous les trous avant de valider."); return; }
  }

  stopTimer();
  locked = true;
  paused = false;
  refreshHintBtn();

  if(type==="single"){
    evaluateOption(q.options[selectedSingle]);
    return;
  }

  if(type==="tf"){
    const opt = (selectedSingle===0) ? q.tf.trueOpt : q.tf.falseOpt;
    evaluateOption(opt);
    return;
  }

  if(type==="multi"){
    const chosen=[...multiSelected].sort((a,b)=>a-b);
    const correctIdx=(q.options||[]).map((o,i)=>o.correct?i:null).filter(v=>v!==null);
    const ok = chosen.length===correctIdx.length && chosen.every((v,i)=>v===correctIdx[i]);
    if(ok){
      addScore(10);
      sfxCorrect(); motion("good");
      showFeedback("good", q.okFb || "‚úÖ Correct.", {allowRetry:false, allowNext:true, missionFail:false});
    }else{
      addStress(STRESS_RULES.wrong);
      sfxWrong(); motion("wrong");
      onAttemptFail(q.badFb || "‚ùå Incorrect.");
    }
    return;
  }

  if(type==="short"){
    const norm = normalize(inputValue);
    const accepted=(q.answers||[]).map(normalize);
    const ok = accepted.includes(norm);
    if(ok){
      addScore(10);
      sfxCorrect(); motion("good");
      showFeedback("good", q.okFb || "‚úÖ Bonne r√©ponse.", {allowRetry:false, allowNext:true, missionFail:false});
    }else{
      addStress(STRESS_RULES.wrong);
      sfxWrong(); motion("wrong");
      onAttemptFail(q.badFb || "‚ùå R√©ponse incorrecte.");
    }
    return;
  }

  if(type==="cloze"){
    const ok = (q.blanks||[]).every(b => normalize(clozeValues[b.key]) === normalize(b.answer));
    if(ok){
      addScore(10);
      sfxCorrect(); motion("good");
      showFeedback("good", q.okFb || "‚úÖ Correct.", {allowRetry:false, allowNext:true, missionFail:false});
    }else{
      addStress(STRESS_RULES.wrong);
      sfxWrong(); motion("wrong");
      onAttemptFail(q.badFb || "‚ùå Texte incorrect.");
    }
    return;
  }

  if(type==="drag_order"){
    const list = document.getElementById("dragList");
    const order = [...list.querySelectorAll("[draggable='true']")].map(x=>x.dataset.id);
    const ok = order.length === (q.expected||[]).length && (q.expected||[]).every((v,i)=>order[i]===v);
    if(ok){
      addScore(10);
      sfxCorrect(); motion("good");
      showFeedback("good", q.okFb || "‚úÖ Bon ordre.", {allowRetry:false, allowNext:true, missionFail:false});
    }else{
      addStress(STRESS_RULES.wrong);
      sfxWrong(); motion("wrong");
      onAttemptFail(q.badFb || "‚ùå Ordre incorrect.");
    }
    return;
  }

  if(type==="image_single"){
    evaluateOption(q.options[selectedSingle]);
    return;
  }

  if(type==="hotspot"){
    const h = (q.hotspots||[])[selectedSingle];
    if(!h){
      locked=false; paused=false; refreshHintBtn(); startTimer();
      return;
    }
    if(h.kind==="ok"){
      addScore(h.pts ?? 10);
      sfxCorrect(); motion("good");
      showFeedback("good", h.fb || "‚úÖ Correct.", {allowRetry:false, allowNext:true, missionFail:false});
    }else if(h.kind==="critical"){
      addStress(STRESS_RULES.critical);
      addScore(h.pts ?? -10);
      sfxCritical(); motion("critical");
      onAttemptFail(h.fb || "üö® Erreur critique.");
    }else{
      addStress(STRESS_RULES.wrong);
      addScore(h.pts ?? 0);
      sfxWrong(); motion("wrong");
      onAttemptFail(h.fb || "‚ùå Incorrect.");
    }
    return;
  }
});

/* ========= Corrig√© (d√©sactiv√© jusqu‚Äô√† la fin) ========= */
function buildAnswerKey(){
  const rows = questions.map((q, i)=>{
    let ans = "‚Äî";
    if(q.type==="single"){
      const oi = (q.options||[]).findIndex(o=>o.kind==="ok");
      ans = oi>=0 ? (q.options[oi].text || "Option") : "‚Äî";
    }else if(q.type==="tf"){
      ans = (q.tf && q.tf.trueOpt && q.tf.trueOpt.kind==="ok") ? "Vrai" : "Faux";
    }else if(q.type==="multi"){
      const a = (q.options||[]).map(o=>o.correct?o.text:null).filter(Boolean);
      ans = a.join(" ; ");
    }else if(q.type==="short"){
      ans = (q.answers||[]).join(" / ");
    }else if(q.type==="drag_order"){
      const map = Object.fromEntries((q.items||[]).map(it=>[it.id,it.text]));
      ans = (q.expected||[]).map(id=>map[id]).join(" ‚Üí ");
    }else if(q.type==="cloze"){
      ans = (q.blanks||[]).map(b=>b.answer).join(" | ");
    }else if(q.type==="image_single"){
      const oi = (q.options||[]).findIndex(o=>o.kind==="ok");
      if(oi>=0){
        ans = `${q.options[oi].label || "?"} ‚Äî ${q.options[oi].caption || ""}`.trim();
      }
    }else if(q.type==="hotspot"){
      ans = "Zone critique : Rachis/colonne (ne pas mobiliser).";
    }
    return `
      <tr>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.08); width:52px; color: rgba(255,255,255,.75);">Q${i+1}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.08); font-weight:900;">${escapeHtml(q.title||"")}</td>
        <td style="padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.08); color: rgba(255,255,255,.86);">${escapeHtml(ans)}</td>
      </tr>
    `;
  }).join("");

  return `
    <div style="font-weight:950; font-size:16px; margin-bottom:10px;">Bonnes r√©ponses</div>
    <div style="overflow:auto; border-radius:14px; border:1px solid rgba(255,255,255,.12);">
      <table style="width:100%; border-collapse:collapse; min-width:700px;">
        <thead>
          <tr>
            <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.12); color: rgba(255,255,255,.65); font-size:12px;">#</th>
            <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.12); color: rgba(255,255,255,.65); font-size:12px;">Question</th>
            <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.12); color: rgba(255,255,255,.65); font-size:12px;">Bonne r√©ponse</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    </div>
  `;
}

showKeyBtn.addEventListener("click", ()=>{
  if(showKeyBtn.disabled) return;
  ensureAudio(); sfxClick();
  keyBody.innerHTML = buildAnswerKey();
  keyOverlay.style.display = "flex";
});
closeKeyBtn.addEventListener("click", ()=>{
  ensureAudio(); sfxClick();
  keyOverlay.style.display = "none";
});

/* ========= Badge save (r√©f√©rence) ========= */
function computeMaxScore(){
  // base 10 par question, hotspot ok = 10 (ou pts), multi=10, etc.
  return questions.reduce((sum, q)=>{
    if(q.type==="hotspot"){
      const ok = (q.hotspots||[]).find(h=>h.kind==="ok");
      return sum + (ok?.pts ?? 10);
    }
    return sum + 10;
  }, 0);
}
function computeBadge(percent){
  if(percent >= 90) return {type:"OR", img:"assets/or.png", name:"ü•á Badge Or"};
  if(percent >= 70) return {type:"ARGENT", img:"assets/argent.png", name:"ü•à Badge Argent"};
  return {type:"BRONZE", img:"assets/bronze.png", name:"ü•â Badge Bronze"};
}
function saveBadge(badge){
  const payload = {
    scenarioId: SCENARIO.id,
    scenario: SCENARIO.label,
    mission: SCENARIO.mission,
    niveau: difficulty,
    badgeType: badge.type,
    badgeName: badge.name,
    score: score,
    img: badge.img,
    ts: new Date().toISOString()
  };
  localStorage.setItem(`badge_s${SCENARIO.id}_${difficulty}`, JSON.stringify(payload));

  const histKey = "badges_history";
  let hist = [];
  try{ hist = JSON.parse(localStorage.getItem(histKey) || "[]"); }catch(e){ hist=[]; }
  hist.unshift(payload);
  localStorage.setItem(histKey, JSON.stringify(hist.slice(0, 50)));
}

/* ========= End Scenario (r√©f√©rence: FIN ‚Äî BADGE OBTENU + d√©sactivation) ========= */
function endScenario(){
  stopTimer();
  locked = true;
  paused = false;

  // progression 100%
  progressBar.style.width = "100%";

  // badge
  const maxScore = Math.max(10, computeMaxScore());
  const pct = clamp(Math.round((score / maxScore) * 100), 0, 100);
  const badge = computeBadge(pct);
  saveBadge(badge);

  // UI fin
  qMeta.textContent = "FIN ‚Äî BADGE OBTENU";
  qTitle.textContent = "üéâ Mission termin√©e";
  qDesc.innerHTML = `
    <div style="margin-top:8px; color: rgba(255,255,255,.86);">
      <div style="font-weight:950; font-size:16px;">${escapeHtml(badge.name)} ‚Äî ${escapeHtml(badge.type)}</div>
      <div style="margin-top:6px; color: rgba(255,255,255,.78); line-height:1.55;">
        Sc√©nario 3 : stabilisation, priorit√©s vitales et protection du rachis.
      </div>
      <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
        <span class="pill">‚≠ê Score final : <b>${score}</b> / ${maxScore}</span>
        <span class="pill">üìä R√©ussite : <b>${pct}%</b></span>
        <span class="pill">üò∞ Stress : <b>${stress}%</b></span>
      </div>
    </div>
  `;

  optionsEl.innerHTML = `
    <div class="opt" style="cursor:default; text-align:center;">
      <div style="display:flex; justify-content:center; gap:14px; align-items:center; flex-wrap:wrap;">
        <div style="width:92px; height:92px; border-radius:18px; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); display:grid; place-items:center;">
          <img src="${badge.img}" alt="${escapeHtml(badge.type)}" style="width:64px; height:64px; object-fit:contain;">
        </div>
        <div style="text-align:left;">
          <div style="font-weight:950; font-size:18px;">${escapeHtml(badge.name)}</div>
          <div style="color: rgba(255,255,255,.74); font-size:13px; margin-top:4px;">Badge enregistr√©</div>
        </div>
      </div>
    </div>
  `;

  // d√©sactiver actions
  validateBtn.disabled = true;
  clearBtn.style.display = "none";
  hintBtn.disabled = true;
  pauseBtn.disabled = true;

  // activer corrig√© + montrer terminer
  showKeyBtn.disabled = false;
  endBtn.style.display = "inline-block";

  sfxVictory();

  endBtn.onclick = ()=>{
    ensureAudio(); sfxClick();
    window.location.href = NEXT_SCENARIO_URL;
  };
}

/* ========= Start ========= */
startBtn.addEventListener("click", async ()=>{
  ensureAudio(); sfxClick();

  // ‚úÖ reset score/stress au lancement
  localStorage.setItem("score","0");
  localStorage.setItem("stress","0");
  setScore(0);
  setStress(0);

  // ‚úÖ reset indices √† 2 (interm√©diaire)
  hintsLeft = HINT_MAX;
  localStorage.setItem(HINT_KEY, String(hintsLeft));
  setHintsUI();

  startOverlay.style.display="none";
  await showLoading(800);
  idx = 0;
  attemptsUsed = 0;
  hintUsedThisQuestion = false;
  setAttemptsUI();
  renderQuestion(0, true);
});

/* ========= Init ========= */
(function init(){
  locked = true;
  paused = false;

  qTitle.textContent = "Pr√©pare-toi‚Ä¶";
  qDesc.innerHTML = `Tu as <b>${TIMER_SECONDS} secondes</b> par question. <b>${ATTEMPTS_MAX}</b> tentatives max. <b>${HINT_MAX}</b> indices pour tout le sc√©nario.`;

  hudQnum.textContent = "1";
  hudTime.textContent = String(TIMER_SECONDS);
  ring.style.setProperty("--p","100%");
  setRingProgress();
  setProgress();

  setAttemptsUI();
  refreshHintBtn();
})();
</script>

<script src="badge-manager.js"></script>
</body>
</html>
