<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sc√©nario 1 ‚Äî √âtouffement ‚Äî (R√©f√©rence Interm√©diaire)</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    :root{
      --glass: rgba(25, 27, 31, .72);
      --glass2: rgba(15, 17, 20, .55);

      --text: rgba(255,255,255,.93);
      --muted: rgba(255,255,255,.70);

      --gold: rgba(255,200,80,1);
      --red: rgba(255,70,70,1);
      --green: rgba(45,200,120,1);
      --blue: rgba(80,170,255,1);
      --ember: rgba(255,150,70,1);
      --ember2: rgba(255,120,50,1);
    }

    *{ box-sizing:border-box; }
    html,body{
      margin:0;
      height:100%;
      background: transparent;
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden; /* ‚úÖ Genially anti-scroll */
    }

    /* ‚úÖ R√©f√©rence (version large) */
    .stage{
      height:100vh;
      padding:10px;
      overflow:hidden;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }
    .wrap{
      width: min(1650px, 100%);
      height:100%;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
    }

    /* ===== Top Tabs (R√©f√©rence) ===== */
    .topTabs{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:2px;
    }
    .levelTab{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:999px;
      background: var(--glass);
      border: 1px solid rgba(255, 200, 150, .22);
      box-shadow: 0 18px 55px rgba(0,0,0,.40);
      backdrop-filter: blur(12px);
      position:relative;
      overflow:hidden;
    }
    .levelTab::after{
      content:"";
      position:absolute; inset:-2px;
      pointer-events:none;
      background:
        radial-gradient(420px 160px at 15% 0%, rgba(255,150,70,.18), transparent 60%),
        radial-gradient(520px 220px at 85% 120%, rgba(80,170,255,.10), transparent 60%);
      opacity:.9;
    }
    .levelDot{
      width:12px; height:12px; border-radius:999px;
      background: linear-gradient(180deg, rgba(255,176,90,1), rgba(255,120,50,1));
      box-shadow: 0 0 0 5px rgba(255,150,70,.16), 0 0 26px rgba(255,150,70,.12);
      position:relative; z-index:2;
    }
    #levelTabText{
      position:relative; z-index:2;
      font-weight:950;
      letter-spacing:.2px;
      white-space:nowrap;
    }

    .progressShell{
      flex: 1 1 220px;
      min-width:220px;
      height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
      box-shadow: 0 18px 55px rgba(0,0,0,.25);
    }
    .progressBar{
      height:100%;
      width:0%;
      border-radius:999px;
      background: linear-gradient(90deg, rgba(80,170,255,.95), rgba(255,150,70,.95));
      transition: width .25s ease;
    }
    .miniHint{
      padding:10px 12px;
      border-radius:999px;
      background: var(--glass);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.78);
      font-weight:950;
      font-size:12px;
      letter-spacing:.2px;
      white-space:nowrap;
      backdrop-filter: blur(12px);
      box-shadow: 0 18px 55px rgba(0,0,0,.35);
    }

    /* ===== HUD (R√©f√©rence) ===== */
    .hud{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 0;
    }

    .hudbox{
      background: var(--glass);
      border: 1px solid rgba(255, 200, 150, .22);
      border-radius: 18px;
      padding: 14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 14px;
      position: relative;
      overflow:hidden;
      box-shadow: 0 18px 65px rgba(0,0,0,.45);
      backdrop-filter: blur(12px);
      min-height:92px;
    }
    .hudbox::after{
      content:"";
      position:absolute;
      inset:-2px;
      pointer-events:none;
      background:
        radial-gradient(420px 160px at 15% 0%, rgba(255,150,70,.18), transparent 60%),
        radial-gradient(520px 220px at 85% 120%, rgba(80,170,255,.10), transparent 60%);
      opacity:.9;
    }

    .profile{
      display:flex;
      align-items:center;
      gap: 14px;
      min-width: 0;
      position: relative;
      z-index:2;
    }

    .avatarFrame{
      width: 92px; height: 92px; border-radius: 24px; padding: 4px;
      background: linear-gradient(180deg, rgba(255,150,70,.36), rgba(80,170,255,.14));
      box-shadow: 0 18px 42px rgba(0,0,0,.45);
      flex: 0 0 auto;
    }
    .avatar{
      width:100%; height:100%;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.12);
      object-fit: cover;
      object-position: 50% 6%;
      transform: scale(1.35);
      transform-origin: 50% 12%;
      background: rgba(255,255,255,.06);
    }

    .ptext{ min-width:0; }
    .pname{
      font-weight: 950; font-size: 22px; line-height: 1.05;
      white-space: nowrap; overflow:hidden; text-overflow: ellipsis;
      text-shadow: 0 14px 30px rgba(0,0,0,.55);
    }
    .prole{
      margin-top: 4px;
      font-weight: 850;
      font-size: 13px;
      color: var(--muted);
      white-space: nowrap; overflow:hidden; text-overflow: ellipsis;
    }

    .chip{
      background: rgba(255,150,70,.14);
      border: 1px solid rgba(255,150,70,.20);
      border-radius: 999px;
      padding: 9px 12px;
      font-size: 12px;
      font-weight: 950;
      white-space: nowrap;
      position: relative;
      z-index:2;
    }

    .stats{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 12px;
      flex-wrap: wrap;
      position: relative;
      z-index:2;
    }

    .pill{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      font-weight: 950;
      font-size: 13px;
      white-space: nowrap;
    }

    .timerPill{
      padding: 8px 10px;
      gap: 10px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }

    .ring{
      width: 40px; height: 40px; border-radius: 999px;
      background: conic-gradient(var(--gold) var(--p, 0%), rgba(255,255,255,.14) 0);
      display:grid; place-items:center;
      box-shadow: 0 0 0 5px rgba(255,200,80,.14), 0 0 28px rgba(255,200,80,.10);
      transition: box-shadow .2s ease, background .2s ease;
    }
    .ringInner{
      width: 28px; height: 28px; border-radius: 999px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      display:grid; place-items:center;
      color: rgba(255,255,255,.9);
      font-size: 14px; font-weight: 950;
    }

    .timeText{ display:flex; align-items:center; gap: 8px; }
    .timeText .label{ font-size: 12px; font-weight: 900; color: rgba(255,255,255,.75); }
    .timeText .sec{ font-size: 16px; font-weight: 950; }

    .timerWarn .ring{
      background: conic-gradient(var(--gold) var(--p, 0%), rgba(255,255,255,.14) 0);
      box-shadow: 0 0 0 5px rgba(255,200,80,.18), 0 0 32px rgba(255,200,80,.14);
    }
    .timerDanger .ring{
      background: conic-gradient(var(--red) var(--p, 0%), rgba(255,255,255,.14) 0);
      box-shadow: 0 0 0 5px rgba(255,70,70,.20), 0 0 40px rgba(255,70,70,.18);
    }

    .stressWrap{
      width: 240px; height: 12px; border-radius: 999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .stressBar{
      height:100%; width:0%;
      background: linear-gradient(90deg, rgba(45,200,120,.95), rgba(255,200,80,.95), rgba(255,70,70,.95));
      transition: width .25s ease;
    }

    /* ===== Frame (R√©f√©rence) ===== */
    .frame{
      background: var(--glass2);
      border: 1px solid rgba(255, 200, 150, .22);
      border-radius: 18px;
      padding: 18px;
      position: relative;
      overflow:hidden;
      box-shadow: 0 18px 70px rgba(0,0,0,.50);
      backdrop-filter: blur(12px);

      flex:1;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:0;
    }
    .frame::after{
      content:"";
      position:absolute; inset:-2px; pointer-events:none;
      background:
        radial-gradient(800px 260px at 55% 0%, rgba(255,150,70,.16), transparent 60%),
        radial-gradient(760px 260px at 40% 120%, rgba(80,170,255,.10), transparent 60%);
      opacity:.9;
    }

    .qmeta{
      position: relative; z-index:2;
      color: rgba(255,255,255,.70);
      font-size: 12px;
      font-weight: 950;
      letter-spacing: .35px;
      text-transform: uppercase;
    }
    .qtitle{
      position: relative; z-index:2;
      margin-top: 6px;
      font-weight: 950;
      font-size: clamp(18px, 2.2vw, 26px);
      line-height: 1.2;
      text-shadow: 0 14px 30px rgba(0,0,0,.55);
    }
    .qdesc{
      position: relative; z-index:2;
      margin-top: 10px;
      color: rgba(255,255,255,.82);
      font-size: 14px;
      line-height: 1.5;
      max-width: 980px;
    }

    .options{
      position: relative; z-index:2;
      display:flex;
      flex-direction:column;
      gap: 12px;
      margin-top: 16px;

      flex:1;
      min-height:0;
      overflow:auto;
      padding-right:6px;
    }

    /* Scrollbar */
    .options::-webkit-scrollbar{ width:10px; }
    .options::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.14);
      border-radius: 999px;
      border: 2px solid rgba(0,0,0,.12);
    }
    .options::-webkit-scrollbar-track{ background: rgba(0,0,0,.10); border-radius:999px; }

    .opt{
      border-radius: 14px;
      padding: 13px 14px;
      font-weight: 950;
      letter-spacing: .2px;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, filter .12s ease, background .12s ease;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(80,170,255,.22), rgba(80,170,255,.14));
      box-shadow: 0 10px 28px rgba(0,0,0,.20);
    }
    .opt:hover{
      transform: translateY(-1px);
      filter: brightness(1.07);
      background: linear-gradient(180deg, rgba(255,150,70,.22), rgba(80,170,255,.10));
    }
    .opt:active{ transform: translateY(0px); filter: brightness(.98); }

    .opt.sel{
      background: linear-gradient(180deg, rgba(255,150,70,.30), rgba(255,120,50,.18));
      border-color: rgba(255,150,70,.30);
      box-shadow: 0 0 0 3px rgba(255,150,70,.10), 0 16px 34px rgba(0,0,0,.28);
    }

    /* ‚úÖ Actions (R√©f√©rence : gauche Corrig√©/Terminer, droite Valider/Effacer) */
    .actions{
      position: relative;
      z-index:2;
      display:flex;
      justify-content:space-between;
      gap: 10px;
      margin-top: 16px;
      flex-wrap: wrap;
      align-items:center;
    }
    .actionsLeft, .actionsRight{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
    }

    .btnNeo{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.90);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 950;
      letter-spacing: .2px;
    }

    .btnPrimary{
      border: none;
      background: linear-gradient(180deg, rgba(255,176,90,1), rgba(255,120,50,1));
      color: rgba(10,12,18,.96);
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 950;
      letter-spacing: .2px;
    }
    .btnPrimary:disabled{
      opacity:.45;
      filter: grayscale(.2);
      cursor: not-allowed;
    }

    /* ===== Overlays (R√©f√©rence) ===== */
    .overlay{
      position: fixed; inset: 0;
      display:none; align-items:center; justify-content:center;
      z-index: 50;
      background: rgba(0,0,0,.48);
      backdrop-filter: blur(8px);
    }
    .modalBox{
      width: min(760px, 92%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(8,10,14,.82);
      box-shadow: 0 26px 90px rgba(0,0,0,.62);
      overflow:hidden;
      position: relative;
    }
    .modalTop{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
    }
    .badgeState{
      font-weight: 950;
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      white-space: nowrap;
    }
    .bGood{ border-color: rgba(45,200,120,.30); background: rgba(45,200,120,.12); }
    .bWarn{ border-color: rgba(255,200,80,.30); background: rgba(255,200,80,.12); }
    .bBad { border-color: rgba(255,70,70,.35); background: rgba(255,70,70,.12); }

    .modalBody{ padding: 16px; color: rgba(255,255,255,.92); line-height: 1.5; font-size: 14px; }
    .modalActions{
      padding: 14px 16px;
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex; justify-content:flex-end; gap: 10px; flex-wrap: wrap;
    }

    .startTitle{ font-weight: 950; font-size: 22px; margin-bottom: 6px; }
    .startText{ color: rgba(255,255,255,.82); font-size: 14px; line-height: 1.45; }
    .startBtn{
      border:none; border-radius: 14px; padding: 12px 16px;
      font-weight: 950; letter-spacing: .3px;
      background: linear-gradient(180deg, rgba(255,176,90,1), rgba(255,120,50,1));
      color: rgba(10,12,18,.96);
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
    }

    /* Key overlay (corrig√©) */
    .keyBox{
      width: min(980px, 95%);
      max-height: 86vh;
      overflow:auto;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(8,10,14,.88);
      box-shadow: 0 26px 90px rgba(0,0,0,.62);
    }
    .keyTop{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
      position: sticky; top: 0;
      background: rgba(8,10,14,.92);
      backdrop-filter: blur(8px);
      z-index:2;
    }
    .keyBody{ padding: 16px; }
    .keyClose{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.90);
      border-radius: 12px;
      padding: 8px 10px;
      font-weight: 950;
    }

    /* Animations */
    .shake{ animation: shake .24s linear 1; }
    @keyframes shake{
      0% { transform: translateX(0px); }
      20%{ transform: translateX(-6px); }
      40%{ transform: translateX(6px); }
      60%{ transform: translateX(-4px); }
      80%{ transform: translateX(4px); }
      100%{ transform: translateX(0px); }
    }
    .pulseGood{ animation: pulseGood .32s ease 1; }
    @keyframes pulseGood{
      from{ box-shadow: 0 0 0 0 rgba(45,200,120,.0); }
      50%{ box-shadow: 0 0 0 7px rgba(45,200,120,.18); }
      to{ box-shadow: 0 0 0 0 rgba(45,200,120,.0); }
    }
    .flashBad{ animation: flashBad .30s ease 1; }
    @keyframes flashBad{
      from{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
      50%{ box-shadow: 0 0 0 7px rgba(255,70,70,.22); }
      to{ box-shadow: 0 0 0 0 rgba(255,70,70,.0); }
    }

    /* Hotspot zones */
    @keyframes hsPulse {
      0% { box-shadow: 0 0 0 0 rgba(255,255,255,.25); border-color: rgba(255,255,255,.55); }
      70% { box-shadow: 0 0 0 14px rgba(255,255,255,0); border-color: rgba(255,255,255,.85); }
      100% { box-shadow: 0 0 0 0 rgba(255,255,255,0); border-color: rgba(255,255,255,.55); }
    }
    .hotspot-zone{
      position:absolute;
      background: transparent !important;
      border: 2px solid rgba(255,255,255,.65);
      border-radius: 16px;
      padding:0;
      margin:0;
      cursor:pointer;
      animation: hsPulse 1.35s infinite;
    }
    .hotspot-zone.sel{
      border-color: rgba(34,197,94,.95);
      box-shadow: 0 0 0 6px rgba(34,197,94,.20);
      animation: none;
    }

    /* Q4 ‚Äì cartes images */
    .imgGrid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:16px;
      margin-top:12px;
    }
    .imgCard{
      border-radius:18px;
      overflow:hidden;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      cursor:pointer;
      transition:.15s ease;
      box-shadow:0 14px 30px rgba(0,0,0,.25);
    }
    .imgCard:hover{ transform:translateY(-3px); filter:brightness(1.05); }
    .imgCard.sel{
      outline:3px solid rgba(255,165,0,.4);
      box-shadow:0 0 0 4px rgba(255,165,0,.25), 0 20px 40px rgba(0,0,0,.35);
    }
    .imgHead{
      padding:12px 16px;
      font-weight:900;
      display:flex;
      justify-content:space-between;
      background:linear-gradient(180deg, rgba(120,180,255,.25), rgba(120,180,255,.10));
    }
    .imgTag{
      width:36px;
      height:36px;
      border-radius:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      background:rgba(0,0,0,.25);
    }
    .imgPic{
      width:100%;
      height:220px;
      object-fit:cover;
      display:block;
    }
    .imgCap{
      padding:14px;
      text-align:center;
      font-weight:800;
    }

    @media (max-width: 980px){
      .hud{ grid-template-columns: 1fr; }
      .stressWrap{ width: 190px; }
      .imgGrid{ grid-template-columns: 1fr; }
      .progressShell{ min-width: 100%; }
    }
  </style>
</head>

<body>
  <div class="stage">
    <div class="wrap">

      <!-- ‚úÖ TopTabs (r√©f√©rence) -->
      <div class="topTabs">
        <div class="levelTab">
          <div class="levelDot"></div>
          <div id="levelTabText">Niveau Interm√©diaire</div>
        </div>

        <div class="progressShell" aria-label="Progression">
          <div class="progressBar" id="progressBar"></div>
        </div>

        <div class="miniHint" id="miniHint">45s ‚Ä¢ 2 ‚Ä¢ 2</div>
      </div>

      <div class="hud">
        <div class="hudbox">
          <div class="profile">
            <div class="avatarFrame">
              <img class="avatar" id="hudAvatar" alt="Avatar">
            </div>
            <div class="ptext">
              <div class="pname" id="hudName">Joueur</div>
              <div class="prole" id="hudRole">R√¥le: ‚Äî</div>
            </div>
          </div>
          <div class="chip" id="difficultyChip">MODE: INTERM√âDIAIRE</div>
        </div>

        <div class="hudbox">
          <div class="stats">
            <div class="pill">‚≠ê <span id="hudScore">0</span></div>
            <div class="pill">Q <span id="hudQnum">1</span>/<span id="hudQtotal">10</span></div>
            <div class="pill">üéØ Tentatives <span id="hudAttempts">1</span>/<span id="hudAttemptsMax">2</span></div>
            <div class="pill">üí° Indices <span id="hudHints">2</span>/<span id="hudHintsMax">2</span></div>

            <div class="pill timerPill" id="timerPill">
              <div class="ring" id="ring"><div class="ringInner">‚è±</div></div>
              <div class="timeText">
                <div class="label">Temps</div>
                <div class="sec"><span id="hudTime">45</span>s</div>
              </div>
            </div>

            <div class="stressWrap" title="Stress">
              <div class="stressBar" id="stressBar"></div>
            </div>

            <button class="btnNeo" id="hintBtn" type="button">üí° Indice</button>
            <button class="btnNeo" id="pauseBtn" type="button">‚è∏ Pause</button>
          </div>
        </div>
      </div>

      <div class="frame" id="frame">
        <div class="qmeta" id="qMeta">Sc√©nario 1 ‚Äî √âtouffement</div>
        <div class="qtitle" id="qTitle">‚Ä¶</div>
        <div class="qdesc" id="qDesc">‚Ä¶</div>

        <div class="options" id="options"></div>

        <div class="actions">
          <div class="actionsLeft">
            <button class="btnNeo" id="showKeyBtn" type="button" disabled>üìò Corrig√©</button>
            <button class="btnPrimary" id="endBtn" type="button" style="display:none;">‚úÖ Terminer</button>
          </div>
          <div class="actionsRight">
            <button class="btnPrimary" id="validateBtn" type="button" disabled>Valider</button>
            <button class="btnNeo" id="clearBtn" type="button" style="display:none;">Effacer</button>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- START overlay -->
  <div class="overlay" id="startOverlay" style="display:flex;">
    <div class="modalBox">
      <div class="modalTop">
        <div class="badgeState bWarn">üéÆ Pr√™t ?</div>
        <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
          Mission ‚Ä¢ √âtouffement
        </div>
      </div>
      <div class="modalBody">
        <div class="startTitle">Tu as une mission.</div>
        <div class="startText" id="startText">
          Tu vas intervenir en situation d‚Äôurgence.
          <br><br>
          <b>R√®gles Interm√©diaire :</b> 45s ‚Ä¢ 2 tentatives ‚Ä¢ 2 indices (1 indice max par question)
          <br><br>
          <b>Si le temps s‚Äô√©coule ou apr√®s 2 tentatives rat√©es, tu retournes au d√©but de la mission (score = 0, stress = 0, indices r√©initialis√©s).</b>
          <br>
          Es-tu pr√™t √† commencer ?
        </div>
      </div>
      <div class="modalActions">
        <button class="startBtn" id="startBtn">D√âMARRER</button>
      </div>
    </div>
  </div>

  <!-- Feedback overlay -->
  <div class="overlay" id="feedbackOverlay">
    <div class="modalBox" id="modalBox">
      <div class="modalTop">
        <div class="badgeState" id="badgeState">‚Äî</div>
        <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
          Score: <span id="modalScore">0</span> ‚Ä¢ Stress: <span id="modalStress">0</span>%
        </div>
      </div>
      <div class="modalBody" id="modalText">‚Ä¶</div>
      <div class="modalActions">
        <button class="btnNeo" id="retryBtn">R√©essayer</button>
        <button class="btnPrimary" id="nextBtn">Suivant</button>
        <button class="btnPrimary" id="okBtn" style="display:none;">OK</button>
      </div>
    </div>
  </div>

  <!-- Hint overlay -->
  <div class="overlay" id="hintOverlay">
    <div class="modalBox">
      <div class="modalTop">
        <div class="badgeState bWarn">üí° Indice</div>
        <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
          Indices restants : <span id="hintLeftTop">0</span>
        </div>
      </div>
      <div class="modalBody" id="hintText">‚Ä¶</div>
      <div class="modalActions">
        <button class="btnPrimary" id="hintCloseBtn">Reprendre</button>
      </div>
    </div>
  </div>

  <!-- Pause overlay -->
  <div class="overlay" id="pauseOverlay">
    <div class="modalBox">
      <div class="modalTop">
        <div class="badgeState bWarn">‚è∏ Pause</div>
        <div style="color: rgba(255,255,255,.75); font-size:12px; font-weight:950;">
          Temps fig√©
        </div>
      </div>
      <div class="modalBody">
        Tu es en pause. Clique sur <b>Reprendre</b> pour continuer.
      </div>
      <div class="modalActions">
        <button class="btnPrimary" id="resumeBtn">Reprendre</button>
      </div>
    </div>
  </div>

  <!-- Key overlay -->
  <div class="overlay" id="keyOverlay">
    <div class="keyBox">
      <div class="keyTop">
        <div class="badgeState bGood">üìò Corrig√©</div>
        <button class="keyClose" id="keyCloseBtn">‚úñ</button>
      </div>
      <div class="keyBody" id="keyBody"></div>
    </div>
  </div>

  <script>
    /* ========= SFX (WebAudio) ========= */
    let audioCtx = null;
    function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
    function tone(freq, dur=0.08, type="sine", gain=0.05){
      ensureAudio();
      const t0 = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type; osc.frequency.value = freq;
      g.gain.value = gain;
      osc.connect(g); g.connect(audioCtx.destination);
      osc.start(t0); osc.stop(t0 + dur);
    }
    function sfxClick(){ tone(520,0.04,"triangle",0.035); }
    function sfxCorrect(){ tone(660,0.07,"sine",0.06); setTimeout(()=>tone(880,0.08,"sine",0.06), 80); }
    function sfxWrong(){ tone(220,0.10,"square",0.05); setTimeout(()=>tone(180,0.12,"square",0.05), 90); }
    function sfxCritical(){ tone(140,0.14,"sawtooth",0.05); setTimeout(()=>tone(120,0.16,"sawtooth",0.05), 120); }
    function sfxAlarmLong(){
      ensureAudio();
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = "sawtooth";
      osc.frequency.setValueAtTime(520, now);
      osc.frequency.linearRampToValueAtTime(380, now + 0.35);
      osc.frequency.linearRampToValueAtTime(520, now + 0.70);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.07, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
      osc.connect(g); g.connect(audioCtx.destination);
      osc.start(now); osc.stop(now + 1.25);
    }
    function sfxVictory(){
      ensureAudio();
      const notes = [
        {f:659,d:0.10},{f:784,d:0.10},{f:988,d:0.14},
        {f:1175,d:0.18},{f:988,d:0.14},{f:1047,d:0.22}
      ];
      let t = 0;
      notes.forEach((n)=>{
        setTimeout(()=>tone(n.f, n.d, "sine", 0.065), t*1000);
        t += n.d + 0.03;
      });
    }

    const el = (id)=>document.getElementById(id);

    /* ======= CONFIG R√©f√©rence Interm√©diaire ======= */
    const SCENARIO = { id: 1, label: "Sc√©nario 1 ‚Äî √âtouffement", mission: "√âtouffement", level: "Niveau Interm√©diaire" };
    const NEXT_GENIALLY_URL = "#"; // üîÅ remplace par ton lien Genially

    const TIMER_SECONDS = 45;
    const MAX_ATTEMPTS = 2;

    const HINT_MAX = 2;
    const HINT_KEY = `hints_left_s${SCENARIO.id}`;

    const STRESS_RULES = { wrong: 10, timeout: 15, critical: 25 };

    /* ======= UI Refs ======= */
    const hudName = el("hudName"), hudRole = el("hudRole"), hudAvatar = el("hudAvatar"), difficultyChip = el("difficultyChip");
    const hudScore = el("hudScore"), hudQnum = el("hudQnum"), hudQtotal = el("hudQtotal"), hudAttempts = el("hudAttempts"), hudAttemptsMax = el("hudAttemptsMax");
    const hudTime = el("hudTime"), ring = el("ring"), timerPill = el("timerPill"), stressBar = el("stressBar");
    const hudHints = el("hudHints"), hudHintsMax = el("hudHintsMax");
    const miniHint = el("miniHint"), progressBar = el("progressBar"), levelTabText = el("levelTabText");
    const qMeta = el("qMeta"), qTitle = el("qTitle"), qDesc  = el("qDesc"), optionsEl = el("options");
    const validateBtn = el("validateBtn"), clearBtn = el("clearBtn");
    const showKeyBtn = el("showKeyBtn"), endBtn = el("endBtn");

    const hintBtn = el("hintBtn"), pauseBtn = el("pauseBtn");

    const startOverlay = el("startOverlay"), startBtn = el("startBtn");

    const feedbackOverlay = el("feedbackOverlay"), modalBox = el("modalBox"), badgeState = el("badgeState"), modalText = el("modalText");
    const modalScore = el("modalScore"), modalStress = el("modalStress");
    const retryBtn = el("retryBtn"), nextBtn = el("nextBtn"), okBtn = el("okBtn"), frame = el("frame");

    const hintOverlay = el("hintOverlay"), hintText = el("hintText"), hintCloseBtn = el("hintCloseBtn"), hintLeftTop = el("hintLeftTop");
    const pauseOverlay = el("pauseOverlay"), resumeBtn = el("resumeBtn");

    const keyOverlay = el("keyOverlay"), keyBody = el("keyBody"), keyCloseBtn = el("keyCloseBtn");

    /* ======= Profil (garde logique Genially) ======= */
    const playerName = (localStorage.getItem("playerName") || localStorage.getItem("player_name") || "Joueur");
    const avatarFile = (localStorage.getItem("avatar") || "medecin_f.png");
    const role = (localStorage.getItem("role") || "pompier");  // ‚úÖ par d√©faut pompier (tes questions)
    const roleLabelMap = { medecin:"M√©decin", infirmier:"Infirmier", pompier:"Pompier" };

    hudName.textContent = "Dr. " + playerName;
    hudRole.textContent = "R√¥le: " + (roleLabelMap[role] || role);
    hudAvatar.src = "assets/avatars/" + avatarFile;

    levelTabText.textContent = SCENARIO.level;
    difficultyChip.textContent = "MODE: INTERM√âDIAIRE";
    miniHint.textContent = "45s ‚Ä¢ 2 ‚Ä¢ 2";

    /* ======= State ======= */
    let score = parseInt(localStorage.getItem("score") || "0", 10);
    let stress = parseInt(localStorage.getItem("stress") || "0", 10);
    if(isNaN(score)) score = 0;
    if(isNaN(stress)) stress = 0;

    let hintsLeft = parseInt(localStorage.getItem(HINT_KEY) || String(HINT_MAX), 10);
    if(isNaN(hintsLeft)) hintsLeft = HINT_MAX;

    let idx = 0;
    let attemptsForCurrentQuestion = 1;
    let locked = true;
    let paused = false;
    let timerId = null;
    let timeLeft = TIMER_SECONDS;
    let hintUsedThisQuestion = false;

    /* ======= QUESTIONS (‚úÖ prises du code dessous, inchang√©es) ======= */
    const questions = [{"type": "single", "title": "Priorit√© bin√¥me", "desc": "Priorit√© n¬∞1 du bin√¥me pompier ?", "options": [{"text": "S√©curiser + √©valuer A/B", "kind": "ok", "fb": "‚úÖ Correct."}, {"text": "Chercher une pi√®ce d‚Äôidentit√©", "kind": "wrong", "fb": "‚ùå Non."}, {"text": "Mettre au sol imm√©diatement", "kind": "wrong", "fb": "‚ùå Pas si consciente."}, {"text": "Donner √† boire", "kind": "critical", "fb": "üö® ERREUR CRITIQUE.", "pts": -10}]}, {"type": "tf", "title": "D√©l√©gation", "desc": "V/F : d√©l√©guer l‚Äôalerte et le DAE pendant les gestes est recommand√©.", "tf": {"trueOpt": {"kind": "ok", "fb": "‚úÖ Vrai."}, "falseOpt": {"kind": "wrong", "fb": "‚ùå Faux."}}}, {"type": "multi", "title": "Gravit√©", "desc": "Signes d‚Äôobstruction grave :", "options": [{"text": "Impossible de parler", "correct": true}, {"text": "Toux inefficace", "correct": true}, {"text": "Cyanose/agitation", "correct": true}, {"text": "Toux forte + parle", "correct": false}], "okFb": "‚úÖ Correct.", "badFb": "‚ùå Revois les signes."}, {"type": "image_single", "title": "Choix de l‚Äôimage", "desc": "Quel visuel correspond au **bon** geste initial (adulte conscient, obstruction grave) ?", "options": [{"label": "A", "caption": "Bouche-√†-bouche imm√©diat", "kind": "wrong", "fb": "‚ùå Non : victime consciente ‚Üí d√©sobstruction d‚Äôabord.", "imgSrc": "assets/q4_a.png"}, {"label": "B", "caption": "5 claques dorsales", "kind": "ok", "fb": "‚úÖ Oui : commencer par les claques dorsales.", "imgSrc": "assets/q4_b.png"}, {"label": "C", "caption": "Victime allong√©e sur le dos", "kind": "wrong", "fb": "‚ùå Non : garder pench√©e en avant.", "imgSrc": "assets/q4_c.png"}]}, {"type": "drag_order", "title": "Ordonner √©quipe", "desc": "Ordonne la conduite √† tenir.", "items": [{"id": "secure", "text": "S√©curiser/EPI"}, {"id": "call", "text": "D√©l√©guer alerte/DAE"}, {"id": "assess", "text": "√âvaluer"}, {"id": "cycle", "text": "Cycles 5/5"}], "expected": ["secure", "call", "assess", "cycle"], "okFb": "‚úÖ Bien.", "badFb": "‚ùå Revois l‚Äôordre."}, {"type": "cloze", "title": "Texte √† trous", "desc": "Compl√®te avec **un seul mot**.", "template": "Si l‚Äôobstruction persiste, poursuivre les cycles jusqu‚Äô√† expulsion ou <b>{blank1}</b>.", "blanks": [{"key": "blank1", "answer": "inconscience"}], "okFb": "‚úÖ inconscience.", "badFb": "‚ùå Attendu : inconscience."}, {"type": "short", "title": "Man≈ìuvre", "desc": "Apr√®s les claques dorsales, quelle man≈ìuvre ? (1 mot)", "answers": ["Heimlich"], "okFb": "‚úÖ Heimlich.", "badFb": "‚ùå Attendu : Heimlich."}, {"type": "single", "title": "Interdit", "desc": "Quel geste est interdit ?", "options": [{"text": "Balayage digital √† l‚Äôaveugle", "kind": "critical", "fb": "üö® ERREUR CRITIQUE.", "pts": -10}, {"text": "Claques dorsales", "kind": "ok", "fb": "‚úÖ Oui."}, {"text": "Compressions abdominales", "kind": "ok", "fb": "‚úÖ Oui."}, {"text": "Alerter / renfort", "kind": "partial", "fb": "üü° Oui.", "pts": 3}]}, {"type": "hotspot", "gate": true, "title": "Hotspot ‚Äî Zone √† traiter", "desc": "", "imgSrc": "scenario_1_hotspot.png", "hotspots": [{"label": "ok", "x": 38.29, "y": 45.07, "w": 23.21, "h": 23.98, "kind": "ok", "fb": "‚úÖ Correct : gorge.", "pts": 10}, {"label": "ko", "x": 46.63, "y": 13.35, "w": 22.22, "h": 27.08, "kind": "wrong", "fb": "‚ùå Faux.", "pts": -2}, {"label": "ko", "x": 55.16, "y": 78.72, "w": 25.79, "h": 19.15, "kind": "wrong", "fb": "‚ùå Faux.", "pts": -2}]}, {"type": "multi", "title": "RCP/DAE", "desc": "Quand pr√©parer la RCP/DAE ?", "options": [{"text": "Inconscience", "correct": true}, {"text": "Respiration absente/anormale", "correct": true}, {"text": "Toux efficace", "correct": false}, {"text": "Aggravation + √©chec", "correct": true}], "okFb": "‚úÖ Correct.", "badFb": "‚ùå Toux efficace ‚â† RCP."}];

    const TOTAL = questions.length;
    hudQtotal.textContent = String(TOTAL);

    /* ======= Helpers ======= */
    function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
    function setScore(v){
      score=v;
      localStorage.setItem("score", String(score));
      hudScore.textContent=String(score);
      modalScore.textContent=String(score);
    }
    function addScore(d){ setScore(score + d); }

    function setStress(v){
      stress=clamp(v,0,100);
      localStorage.setItem("stress", String(stress));
      stressBar.style.width=stress+"%";
      modalStress.textContent=String(stress);
    }
    function addStress(d){ setStress(stress + d); }

    function setHints(v){
      hintsLeft = clamp(v,0,HINT_MAX);
      localStorage.setItem(HINT_KEY, String(hintsLeft));
      hudHints.textContent = String(hintsLeft);
      hudHintsMax.textContent = String(HINT_MAX);
      hintBtn.disabled = (hintsLeft<=0 || hintUsedThisQuestion || locked);
      hintLeftTop.textContent = String(hintsLeft);
      miniHint.textContent = `${TIMER_SECONDS}s ‚Ä¢ ${MAX_ATTEMPTS} ‚Ä¢ ${hintsLeft}`;
    }
    function consumeHint(){
      if(hintsLeft<=0 || hintUsedThisQuestion || locked) return false;
      hintUsedThisQuestion = true;
      setHints(hintsLeft-1);
      return true;
    }

    function setAttemptsUI(){
      hudAttempts.textContent = String(attemptsForCurrentQuestion);
      hudAttemptsMax.textContent = String(MAX_ATTEMPTS);
    }

    function setProgress(){
      const pct = clamp(Math.round((idx / TOTAL) * 100), 0, 100);
      progressBar.style.width = pct + "%";
    }

    function setRingProgress(){
      const p = clamp(Math.round((timeLeft / TIMER_SECONDS) * 100), 0, 100);
      ring.style.setProperty("--p", p + "%");
      timerPill.classList.remove("timerWarn","timerDanger");
      if(timeLeft <= 5) timerPill.classList.add("timerDanger");
      else if(timeLeft <= 10) timerPill.classList.add("timerWarn");
    }

    function stopTimer(){ clearInterval(timerId); timerId=null; }
    function startTimer(){
      stopTimer();
      timeLeft = TIMER_SECONDS;
      hudTime.textContent = String(timeLeft);
      setRingProgress();
      timerId = setInterval(()=>{
        if(locked || paused) return;
        timeLeft--;
        hudTime.textContent = String(timeLeft);
        setRingProgress();
        if(timeLeft <= 0){
          stopTimer();
          sfxAlarmLong();
          addStress(STRESS_RULES.timeout);
          attemptsForCurrentQuestion++;
          setAttemptsUI();

          if(attemptsForCurrentQuestion > MAX_ATTEMPTS){
            missionFail(`‚è±Ô∏è Temps √©coul√© (${MAX_ATTEMPTS} fois). Mission √©chou√©e. Retour au d√©part‚Ä¶ (score remis √† z√©ro)`);
          }else{
            showFeedback("warn", `‚è±Ô∏è Temps √©coul√©. (Tentative ${attemptsForCurrentQuestion}/${MAX_ATTEMPTS})`, {allowRetry:true, allowNext:false, isMissionFail:false});
          }
        }
      }, 1000);
    }

    function motion(type){
      frame.classList.remove("shake","pulseGood","flashBad");
      modalBox.classList.remove("shake","pulseGood","flashBad");
      if(type==="good") frame.classList.add("pulseGood");
      else if(type==="wrong") modalBox.classList.add("shake");
      else if(type==="critical"){ modalBox.classList.add("shake"); frame.classList.add("flashBad"); }
    }

    /* ======= Selection state ======= */
    let selectedSingle = null;
    let multiSelected = new Set();
    let inputValue = "";
    let clozeValues = {};

    function resetState(){
      selectedSingle=null;
      multiSelected.clear();
      inputValue="";
      clozeValues={};
      validateBtn.disabled=true;
      hintUsedThisQuestion = false;
      setHints(hintsLeft); // refresh disable logic
    }

    function mkOpt(text){
      const d = document.createElement("div");
      d.className="opt";
      d.textContent=text;
      return d;
    }

    function showEl(x){ x.style.display="flex"; }
    function hideEl(x){ x.style.display="none"; }

    /* ======= Render ======= */
    function renderQuestion(i, resetAttempts=true){
      locked=false;
      paused=false;
      hideEl(feedbackOverlay);
      hideEl(pauseOverlay);
      hideEl(hintOverlay);
      hideEl(keyOverlay);

      if(resetAttempts){
        attemptsForCurrentQuestion=1;
        setAttemptsUI();
      }

      resetState();
      setProgress();

      const q = questions[i];
      qMeta.textContent = `${SCENARIO.label} ‚Ä¢ ${SCENARIO.level}`;
      qTitle.textContent = q.title || "‚Äî";
      qDesc.innerHTML = q.desc || "";
      optionsEl.innerHTML = "";
      clearBtn.style.display = "none";

      validateBtn.disabled = true;

      const type = q.type;

      if(type==="single"){
        q.options.forEach((opt, oi)=>{
          const d = mkOpt(opt.text);
          d.onclick=()=>{
            if(locked || paused) return;
            sfxClick();
            [...optionsEl.children].forEach(x=>x.classList.remove("sel"));
            d.classList.add("sel");
            selectedSingle=oi;
            validateBtn.disabled=false;
          };
          optionsEl.appendChild(d);
        });
      }

      if(type==="tf"){
        const opts=[{label:"Vrai",data:q.tf.trueOpt},{label:"Faux",data:q.tf.falseOpt}];
        opts.forEach((o, oi)=>{
          const d = mkOpt(o.label);
          d.onclick=()=>{
            if(locked || paused) return;
            sfxClick();
            [...optionsEl.children].forEach(x=>x.classList.remove("sel"));
            d.classList.add("sel");
            selectedSingle=oi;
            validateBtn.disabled=false;
          };
          optionsEl.appendChild(d);
        });
      }

      if(type==="multi"){
        clearBtn.style.display="inline-block";
        q.options.forEach((opt, oi)=>{
          const d=mkOpt(opt.text);
          d.onclick=()=>{
            if(locked || paused) return;
            sfxClick();
            if(multiSelected.has(oi)){ multiSelected.delete(oi); d.classList.remove("sel"); }
            else { multiSelected.add(oi); d.classList.add("sel"); }
            validateBtn.disabled = (multiSelected.size===0);
          };
          optionsEl.appendChild(d);
        });
      }

      if(type==="short"){
        clearBtn.style.display="inline-block";
        const box = document.createElement("div");
        box.className="opt"; box.style.cursor="default";
        box.innerHTML = `
          <div style="font-weight:950; margin-bottom:8px;">Ta r√©ponse</div>
          <input id="shortInput" class="form-control" type="text" placeholder="√âcris ici‚Ä¶"
            style="background: rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.18); color: rgba(255,255,255,.92);" />
          <div style="margin-top:8px; font-size:12px; color: rgba(255,255,255,.72);">Astuce : une valeur courte suffit.</div>
        `;
        optionsEl.appendChild(box);
        const inp = box.querySelector("#shortInput");
        inp.addEventListener("input", ()=>{
          if(locked || paused) return;
          inputValue = inp.value;
          validateBtn.disabled = (inp.value.trim().length===0);
        });
      }

      if(type==="image_single"){
        const grid = document.createElement("div");
        grid.className = "imgGrid";
        q.options.forEach((opt, oi)=>{
          const card = document.createElement("div");
          card.className = "imgCard";
          card.innerHTML = `
            <div class="imgHead">
              <div>Option ${opt.label}</div>
              <div class="imgTag">${opt.label}</div>
            </div>
            <img class="imgPic" src="${opt.imgSrc}" alt="Option ${opt.label}">
            <div class="imgCap">${opt.caption}</div>
          `;
          card.onclick = ()=>{
            if(locked || paused) return;
            sfxClick();
            [...grid.querySelectorAll(".imgCard")].forEach(c=>c.classList.remove("sel"));
            card.classList.add("sel");
            selectedSingle = oi;
            validateBtn.disabled = false;
          };
          grid.appendChild(card);
        });
        optionsEl.appendChild(grid);
      }

      if(type==="hotspot"){
        clearBtn.style.display="inline-block";

        const msg = document.createElement("div");
        msg.className="pill";
        msg.style.marginBottom="10px";
        msg.innerHTML = "üéØ <b>Clique sur la zone correcte</b> sur l‚Äôimage, puis appuie sur <b>Valider</b>.";
        optionsEl.appendChild(msg);

        const wrap = document.createElement("div");
        wrap.style.position="relative";
        wrap.style.width="100%";
        wrap.style.maxWidth="760px";
        wrap.style.margin="0 auto";
        wrap.style.borderRadius="18px";
        wrap.style.overflow="hidden";
        wrap.style.border="1px solid rgba(255,255,255,.14)";
        wrap.style.background="rgba(0,0,0,.18)";
        wrap.innerHTML = `<img src="${q.imgSrc||""}" alt="hotspot" style="width:100%; height:240px; object-fit:cover; display:block;">`;
        optionsEl.appendChild(wrap);

        const zones = document.createElement("div");
        zones.style.position="absolute";
        zones.style.inset="0";
        zones.style.pointerEvents="auto";
        wrap.appendChild(zones);

        selectedSingle = null;
        validateBtn.disabled = true;

        (q.hotspots||[]).forEach((h, hi)=>{
          const z = document.createElement("button");
          z.type="button";
          z.className="hotspot-zone";
          z.style.left = h.x + "%";
          z.style.top  = h.y + "%";
          z.style.width = h.w + "%";
          z.style.height= h.h + "%";
          z.style.pointerEvents="auto";
          z.onclick=()=>{
            if(locked || paused) return;
            sfxClick();
            [...zones.querySelectorAll("button")].forEach(b=>b.classList.remove("sel"));
            z.classList.add("sel");
            selectedSingle = hi;
            validateBtn.disabled = false;
          };
          zones.appendChild(z);
        });
      }

      if(type==="drag_order"){
        clearBtn.style.display="inline-block";

        const note = document.createElement("div");
        note.className="pill";
        note.style.marginBottom="10px";
        note.textContent="üñ±Ô∏è Glisse-d√©pose les cartes pour les mettre dans l‚Äôordre.";
        optionsEl.appendChild(note);

        const list = document.createElement("div");
        list.id="dragList";
        list.style.display="grid";
        list.style.gap="10px";

        const items = [...q.items];
        for(let k=items.length-1;k>0;k--){
          const j=Math.floor(Math.random()*(k+1));
          [items[k],items[j]]=[items[j],items[k]];
        }

        items.forEach((it)=>{
          const row = document.createElement("div");
          row.className="opt";
          row.setAttribute("draggable","true");
          row.dataset.id = it.id;
          row.innerHTML = `<div style="font-weight:950;">${it.text}</div><div style="font-size:12px; color: rgba(255,255,255,.68); margin-top:3px;">(glisser)</div>`;
          list.appendChild(row);
        });

        optionsEl.appendChild(list);

        let dragSrc = null;
        list.addEventListener("dragstart",(e)=>{
          const target = e.target.closest("[draggable='true']");
          if(!target) return;
          dragSrc = target;
          e.dataTransfer.effectAllowed="move";
          target.style.opacity="0.6";
        });
        list.addEventListener("dragend",(e)=>{
          const target = e.target.closest("[draggable='true']");
          if(target) target.style.opacity="1";
          dragSrc=null;
        });
        list.addEventListener("dragover",(e)=>{
          e.preventDefault();
          const over = e.target.closest("[draggable='true']");
          if(!over || !dragSrc || over===dragSrc) return;
          const rect = over.getBoundingClientRect();
          const before = (e.clientY - rect.top) < rect.height/2;
          list.insertBefore(dragSrc, before ? over : over.nextSibling);
        });
        list.addEventListener("drop",(e)=>{
          e.preventDefault();
          validateBtn.disabled=false;
        });

        validateBtn.disabled=false; // on autorise directement (l‚Äôordre existe)
      }

      if(type==="cloze"){
        clearBtn.style.display="inline-block";
        const box = document.createElement("div");
        box.className="opt"; box.style.cursor="default";

        const html = (q.template||"").replace("{blank1}",
          `<input data-k="blank1" class="form-control" style="display:inline-block; width:240px; margin:0 6px; background: rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.18); color: rgba(255,255,255,.92);" placeholder="..." />`
        );

        box.innerHTML = `<div style="line-height:1.8;">${html}</div>`;
        optionsEl.appendChild(box);

        const inputs = box.querySelectorAll("input[data-k]");
        inputs.forEach(inp=>{
          inp.addEventListener("input", ()=>{
            if(locked || paused) return;
            clozeValues[inp.dataset.k] = inp.value;
            const filled = (q.blanks||[]).every(b => (clozeValues[b.key]||"").trim().length>0);
            validateBtn.disabled = !filled;
          });
        });
      }

      hudQnum.textContent = String(i+1);
      startTimer();
      setHints(hintsLeft);
    }

    /* ======= Clear ======= */
    clearBtn.onclick = ()=>{
      if(locked) return;
      sfxClick();
      renderQuestion(idx, false);
    };

    /* ======= Pause ======= */
    pauseBtn.onclick = ()=>{
      if(locked) return;
      sfxClick();
      paused = true;
      showEl(pauseOverlay);
    };
    resumeBtn.onclick = ()=>{
      sfxClick();
      hideEl(pauseOverlay);
      paused = false;
    };

    /* ======= Hint (indices) ======= */
    function buildHintFor(q){
      // Si tu veux des indices personnalis√©s : ajoute q.hint dans tes questions.
      if(q.hint) return q.hint;

      // Sinon : on g√©n√®re un indice "safe" (pas la r√©ponse compl√®te).
      if(q.type==="single"){
        const ok = q.options.find(o=>o.kind==="ok");
        return `Pense √† la priorit√© op√©rationnelle : ‚Äú${(ok?.text||"") }‚Äù concerne l‚Äôaction la plus imm√©diate.`;
      }
      if(q.type==="tf"){
        const ans = (q.tf.trueOpt.kind==="ok") ? "Vrai" : "Faux";
        return `Rappelle-toi l‚Äôorganisation : d√©l√©guer l‚Äôalerte/DAE pendant les gestes. (R√©ponse : ${ans})`;
      }
      if(q.type==="multi"){
        const count = q.options.filter(o=>o.correct).length;
        return `Il y a ${count} bonne(s) proposition(s). Obstruction grave = incapacit√© √† parler + toux inefficace + signes respiratoires.`;
      }
      if(q.type==="image_single"){
        const ok = q.options.find(o=>o.kind==="ok");
        return `Le bon geste initial commence par l‚Äôaction d√©crite dans l‚Äôoption ${ok?.label || "‚Äî"}.`;
      }
      if(q.type==="drag_order"){
        const first = q.expected?.[0];
        const map = Object.fromEntries((q.items||[]).map(it=>[it.id,it.text]));
        return `Commence par : "${map[first] || "S√©curiser"}", puis encha√Æne logiquement.`;
      }
      if(q.type==="cloze"){
        const a = (q.blanks?.[0]?.answer||"").trim();
        return `Le mot attendu commence par ‚Äú${a.slice(0,2)}‚Ä¶‚Äù.`;
      }
      if(q.type==="short"){
        const a = (q.answers?.[0]||"").trim();
        return `R√©ponse attendue : mot unique, commence par ‚Äú${a.slice(0,2)}‚Ä¶‚Äù.`;
      }
      if(q.type==="hotspot"){
        return `Cible la zone en lien direct avec l‚Äô√©touffement (respiration / gorge).`;
      }
      return `Concentre-toi sur la r√®gle de base d‚Äô√©touffement : claques dorsales, compressions, puis RCP si inconscience.`;
    }

    hintBtn.onclick = ()=>{
      if(locked || paused) return;
      sfxClick();
      const q = questions[idx];
      if(!consumeHint()) return;

      paused = true; // ‚úÖ indice pause le timer
      hintText.innerHTML = buildHintFor(q);
      hintLeftTop.textContent = String(hintsLeft);
      showEl(hintOverlay);
    };
    hintCloseBtn.onclick = ()=>{
      sfxClick();
      hideEl(hintOverlay);
      paused = false;
    };

    /* ======= Feedback overlay ======= */
    function showFeedback(kind, text, {allowRetry, allowNext, isMissionFail}){
      badgeState.className="badgeState";
      if(kind==="good"){ badgeState.classList.add("bGood"); badgeState.textContent="‚úÖ Bonne r√©ponse"; }
      if(kind==="warn"){ badgeState.classList.add("bWarn"); badgeState.textContent="‚ö†Ô∏è √Ä corriger"; }
      if(kind==="bad") { badgeState.classList.add("bBad");  badgeState.textContent="üö® Mission √©chou√©e"; }

      modalText.textContent = text;
      showEl(feedbackOverlay);

      retryBtn.style.display = allowRetry ? "inline-block" : "none";
      nextBtn.style.display  = allowNext  ? "inline-block" : "none";
      okBtn.style.display    = "none";

      retryBtn.onclick = ()=>{
        hideEl(feedbackOverlay);
        locked=false;
        paused=false;
        startTimer();
      };

      nextBtn.onclick = ()=>{
        hideEl(feedbackOverlay);
        idx++;
        if(idx < TOTAL) renderQuestion(idx,true);
        else endScenario();
      };

      if(isMissionFail){
        retryBtn.style.display="none";
        nextBtn.style.display="none";
        okBtn.style.display="inline-block";
        okBtn.textContent="OK";
        okBtn.onclick = ()=>{
          hideEl(feedbackOverlay);
          resetMission(true);
        };
      }
    }

    function missionFail(message){
      stopTimer();
      locked=true;
      paused=false;
      showFeedback("bad", message, {allowRetry:false, allowNext:false, isMissionFail:true});
      motion("critical");
    }

    function failedAttempt(baseMsg){
      attemptsForCurrentQuestion++;
      setAttemptsUI();

      if(attemptsForCurrentQuestion > MAX_ATTEMPTS){
        sfxAlarmLong();
        missionFail(`‚ùå ${MAX_ATTEMPTS} tentatives rat√©es. Mission √©chou√©e. Retour au d√©part‚Ä¶ (score remis √† z√©ro)`);
        return;
      }
      showFeedback("warn", `${baseMsg} (Tentative ${attemptsForCurrentQuestion}/${MAX_ATTEMPTS})`, {allowRetry:true, allowNext:false, isMissionFail:false});
    }

    function evaluateOption(opt){
      if(opt.kind==="ok"){
        addScore(opt.pts ?? 10);
        showFeedback("good", opt.fb || "‚úÖ Correct.", {allowRetry:false, allowNext:true, isMissionFail:false});
        sfxCorrect(); motion("good"); return;
      }
      if(opt.kind==="critical"){
        addStress(STRESS_RULES.critical);
        addScore(opt.pts ?? -10);
        sfxCritical(); motion("critical");
        failedAttempt(opt.fb || "üö® Erreur critique."); return;
      }
      if(opt.kind==="partial"){
        addStress(STRESS_RULES.wrong);
        addScore(opt.pts ?? 3);
        sfxWrong(); motion("wrong");
        failedAttempt(opt.fb || "üü° Partiel."); return;
      }
      addStress(STRESS_RULES.wrong);
      sfxWrong(); motion("wrong");
      failedAttempt(opt.fb || "‚ùå Incorrect.");
    }

    /* ======= Validate ======= */
    validateBtn.onclick = ()=>{
      if(locked || paused) return;

      const q = questions[idx];
      const type = q.type;

      const needSelection = (msg)=>{
        sfxClick();
        stopTimer();
        locked=true;
        showFeedback("warn", msg, {allowRetry:false, allowNext:false, isMissionFail:false});
        retryBtn.style.display="none";
        nextBtn.style.display="none";
        okBtn.style.display="inline-block";
        okBtn.textContent="OK";
        okBtn.onclick = ()=>{
          hideEl(feedbackOverlay);
          locked=false;
          startTimer();
        };
      };

      if(type==="single" || type==="tf" || type==="image_single" || type==="hotspot"){
        if(selectedSingle===null){ needSelection("Choisis une r√©ponse avant de valider."); return; }
      }
      if(type==="multi"){
        if(multiSelected.size===0){ needSelection("S√©lectionne au moins une proposition avant de valider."); return; }
      }
      if(type==="short"){
        if((inputValue||"").trim().length===0){ needSelection("√âcris une r√©ponse avant de valider."); return; }
      }
      if(type==="cloze"){
        const filled = (q.blanks||[]).every(b => ((clozeValues[b.key]||"").trim().length>0));
        if(!filled){ needSelection("Compl√®te tous les trous avant de valider."); return; }
      }

      stopTimer();
      locked=true;

      if(type==="single"){
        evaluateOption(q.options[selectedSingle]); return;
      }

      if(type==="tf"){
        const opt = (selectedSingle===0) ? q.tf.trueOpt : q.tf.falseOpt;
        evaluateOption(opt); return;
      }

      if(type==="multi"){
        const chosen=[...multiSelected].sort((a,b)=>a-b);
        const correctIdx=q.options.map((o,i)=>o.correct?i:null).filter(v=>v!==null);
        const ok = chosen.length===correctIdx.length && chosen.every((v,i)=>v===correctIdx[i]);

        if(ok){
          addScore(10);
          showFeedback("good", q.okFb || "‚úÖ Correct.", {allowRetry:false, allowNext:true, isMissionFail:false});
          sfxCorrect(); motion("good");
        }else{
          addStress(STRESS_RULES.wrong);
          sfxWrong(); motion("wrong");
          failedAttempt(q.badFb || "‚ùå Incorrect.");
        }
        return;
      }

      if(type==="short"){
        const norm=(inputValue||"").trim().toLowerCase();
        const accepted=(q.answers||[]).map(a=>String(a).trim().toLowerCase());
        const ok = accepted.includes(norm);

        if(ok){
          addScore(10);
          showFeedback("good", q.okFb || "‚úÖ Bonne r√©ponse.", {allowRetry:false, allowNext:true, isMissionFail:false});
          sfxCorrect(); motion("good");
        }else{
          addStress(STRESS_RULES.wrong);
          sfxWrong(); motion("wrong");
          failedAttempt(q.badFb || "‚ùå R√©ponse incorrecte.");
        }
        return;
      }

      if(type==="image_single"){
        evaluateOption(q.options[selectedSingle]); return;
      }

      if(type==="hotspot"){
        const h = (q.hotspots||[])[selectedSingle];
        if(!h){
          locked=false;
          startTimer();
          return;
        }
        if(h.kind==="ok"){
          addScore(h.pts ?? 10);
          showFeedback("good", h.fb || "‚úÖ Correct.", {allowRetry:false, allowNext:true, isMissionFail:false});
          sfxCorrect(); motion("good");
        }else if(h.kind==="critical"){
          addStress(STRESS_RULES.critical);
          addScore(h.pts ?? -10);
          sfxCritical(); motion("critical");
          failedAttempt(h.fb || "üö® Erreur critique.");
        }else{
          addStress(STRESS_RULES.wrong);
          addScore(h.pts ?? 0);
          sfxWrong(); motion("wrong");
          failedAttempt(h.fb || "‚ùå Incorrect.");
        }
        return;
      }

      if(type==="drag_order"){
        const list = el("dragList");
        const order = [...list.querySelectorAll("[draggable='true']")].map(x=>x.dataset.id);
        const ok = order.length===q.expected.length && q.expected.every((v,i)=>order[i]===v);

        if(ok){
          addScore(10);
          showFeedback("good", q.okFb || "‚úÖ Bon ordre.", {allowRetry:false, allowNext:true, isMissionFail:false});
          sfxCorrect(); motion("good");
        }else{
          addStress(STRESS_RULES.wrong);
          sfxWrong(); motion("wrong");
          failedAttempt(q.badFb || "‚ùå Ordre incorrect.");
        }
        return;
      }

      if(type==="cloze"){
        const ok = (q.blanks||[]).every(b => ((clozeValues[b.key]||"").trim().toLowerCase() === b.answer.trim().toLowerCase()));
        if(ok){
          addScore(10);
          showFeedback("good", q.okFb || "‚úÖ Correct.", {allowRetry:false, allowNext:true, isMissionFail:false});
          sfxCorrect(); motion("good");
        }else{
          addStress(STRESS_RULES.wrong);
          sfxWrong(); motion("wrong");
          failedAttempt(q.badFb || "‚ùå Texte incorrect.");
        }
        return;
      }
    };

    /* ======= Reset mission ======= */
    function resetMission(showStart=true){
      stopTimer();
      idx=0;
      attemptsForCurrentQuestion=1;
      setAttemptsUI();

      setScore(0);
      setStress(0);

      // ‚úÖ indices reset √† 2 sur D√âMARRER / reset mission
      setHints(HINT_MAX);
      hintUsedThisQuestion = false;

      locked=true;
      paused=false;

      if(showStart) startOverlay.style.display="flex";
      setProgress();
      hudQnum.textContent="1";
      hudTime.textContent=String(TIMER_SECONDS);
      ring.style.setProperty("--p","100%");
      setRingProgress();
    }

    /* ======= Corrig√© (d√©sactiv√© jusqu‚Äô√† la fin) ======= */
    function escapeHtml(str){ return String(str).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }

    function buildAnswerKey(){
      const rows = questions.map((q, i)=>{
        let ans = "";
        if(q.type==="single"){
          const oi = q.options.findIndex(o=>o.kind==="ok");
          ans = oi>=0 ? q.options[oi].text : "‚Äî";
        }else if(q.type==="image_single"){
          const oi = q.options.findIndex(o=>o.kind==="ok");
          ans = oi>=0 ? `${q.options[oi].label} ‚Äî ${q.options[oi].caption}` : "‚Äî";
        }else if(q.type==="tf"){
          ans = (q.tf.trueOpt.kind==="ok") ? "Vrai" : "Faux";
        }else if(q.type==="multi"){
          const a = q.options.map((o)=>o.correct?o.text:null).filter(Boolean);
          ans = a.join(" ; ");
        }else if(q.type==="short"){
          ans = (q.answers||[]).join(" / ");
        }else if(q.type==="drag_order"){
          const map = Object.fromEntries(q.items.map(it=>[it.id,it.text]));
          ans = (q.expected||[]).map(id=>map[id]).join(" ‚Üí ");
        }else if(q.type==="cloze"){
          ans = (q.blanks||[]).map(b=>b.answer).join(" | ");
        }else if(q.type==="hotspot"){
          const ok = (q.hotspots||[]).find(h=>h.kind==="ok");
          ans = ok ? "Zone correcte (gorge)" : "‚Äî";
        }else{
          ans = "‚Äî";
        }
        return `
          <tr>
            <td style="padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.08); width:56px; color: rgba(255,255,255,.75);">Q${i+1}</td>
            <td style="padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.08); font-weight:900;">${escapeHtml(q.title||"")}</td>
            <td style="padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.08); color: rgba(255,255,255,.86);">${escapeHtml(ans)}</td>
          </tr>`;
      }).join("");

      return `
        <div style="font-weight:950; font-size:16px; margin-bottom:10px;">Bonnes r√©ponses</div>
        <div style="overflow:auto; border-radius:14px; border:1px solid rgba(255,255,255,.12);">
          <table style="width:100%; border-collapse:collapse; min-width:720px;">
            <thead>
              <tr>
                <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.12); color: rgba(255,255,255,.65); font-size:12px;">#</th>
                <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.12); color: rgba(255,255,255,.65); font-size:12px;">Question</th>
                <th style="text-align:left; padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.12); color: rgba(255,255,255,.65); font-size:12px;">Bonne r√©ponse</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>`;
    }

    showKeyBtn.onclick = ()=>{
      if(showKeyBtn.disabled) return;
      sfxClick();
      keyBody.innerHTML = buildAnswerKey();
      showEl(keyOverlay);
    };
    keyCloseBtn.onclick = ()=>{ sfxClick(); hideEl(keyOverlay); };

    /* ======= Terminer ======= */
    endBtn.onclick = ()=>{
      sfxClick();
      window.location.href = NEXT_GENIALLY_URL;
    };

    /* ======= Fin + Badge ======= */
    function computeBadge(percent){
      if(percent >= 90) return {type:"OR", img:"assets/or.png"};
      if(percent >= 70) return {type:"ARGENT", img:"assets/argent.png"};
      return {type:"BRONZE", img:"assets/bronze.png"};
    }

    function saveBadge(payload){
      const key = `badge_s${SCENARIO.id}_intermediaire`;
      localStorage.setItem(key, JSON.stringify(payload));

      const histKey = "badges_history";
      let hist = [];
      try{ hist = JSON.parse(localStorage.getItem(histKey) || "[]"); }catch(e){ hist=[]; }
      hist.unshift({
        scenarioId: SCENARIO.id,
        mission: SCENARIO.mission,
        niveau: "interm√©diaire",
        badgeType: payload.badgeType,
        badgeName: payload.badgeName,
        score: payload.score,
        dateISO: payload.ts
      });
      localStorage.setItem(histKey, JSON.stringify(hist));
    }

    function endScenario(){
      stopTimer();
      locked=true;
      paused=false;

      // UI lock
      validateBtn.disabled = true;
      clearBtn.style.display="none";
      hintBtn.disabled = true;
      pauseBtn.disabled = true;

      // enable key + show end
      showKeyBtn.disabled = false;
      endBtn.style.display = "inline-block";

      // progress 100%
      progressBar.style.width = "100%";

      const maxScore = TOTAL * 10;
      const percent = clamp(Math.round((score / maxScore) * 100), 0, 100);
      const badge = computeBadge(percent);

      const badgeName = `${badge.type} ‚Äî ${roleLabelMap[role] || role} (Interm√©diaire)`;
      const ts = new Date().toISOString();

      saveBadge({
        scenarioId: SCENARIO.id,
        mission: SCENARIO.mission,
        niveau: "interm√©diaire",
        badgeType: badge.type,
        badgeName,
        score,
        percent,
        img: badge.img,
        ts
      });

      qMeta.textContent = "FIN ‚Äî BADGE OBTENU";
      qTitle.textContent = "üéâ F√©licitations !";
      sfxVictory();

      const stressState = (stress>=80) ? "üî¥ Pression extr√™me" : (stress>=40) ? "üü° Sous pression" : "üü¢ Calme";

      qDesc.innerHTML = `
        <div style="margin-top:8px; color: rgba(255,255,255,.86);">
          <div style="display:flex; gap:14px; flex-wrap:wrap; align-items:center; margin-top:8px;">
            <div style="width:92px; height:92px; border-radius:18px; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); display:grid; place-items:center;">
              <img src="${badge.img}" alt="${badge.type}" style="width:64px; height:64px; object-fit:contain;">
            </div>
            <div>
              <div style="font-weight:950; font-size:18px;">üèÖ ${escapeHtml(badgeName)}</div>
              <div style="margin-top:6px; color: rgba(255,255,255,.78); line-height:1.55;">
                Score : <b>${score}</b> / ${maxScore} (${percent}%)
                <br>Stress : <b>${stress}%</b> (${escapeHtml(stressState)})
              </div>
            </div>
          </div>
        </div>
      `;

      optionsEl.innerHTML = `
        <div class="opt" style="cursor:default;">
          <div style="font-weight:950; font-size:16px;">üìå Prochaine √©tape</div>
          <div style="margin-top:8px; color: rgba(255,255,255,.78); line-height:1.55;">
            Tu peux ouvrir le <b>Corrig√©</b> (bouton en bas √† gauche), puis cliquer sur <b>Terminer</b>.
          </div>
        </div>
      `;
    }

    /* ======= Start ======= */
    startBtn.addEventListener("click", ()=>{
      ensureAudio(); sfxClick();

      // ‚úÖ reset au d√©marrage (r√©f√©rence)
      localStorage.setItem("stress", "0");
      localStorage.setItem("score", "0");
      stress = 0; score = 0;
      setStress(0); setScore(0);

      // ‚úÖ reset indices √† 2 au clic D√âMARRER
      setHints(HINT_MAX);
      hintUsedThisQuestion = false;

      startOverlay.style.display="none";
      idx=0;
      attemptsForCurrentQuestion=1;
      setAttemptsUI();
      setProgress();
      renderQuestion(0, true);
    });

    /* ======= Init ======= */
    (function init(){
      locked=true;
      qMeta.textContent = SCENARIO.label;
      qTitle.textContent="Pr√©pare-toi‚Ä¶";
      qDesc.innerHTML = `Tu as <b>${TIMER_SECONDS} secondes</b> par question ‚Ä¢ <b>${MAX_ATTEMPTS}</b> tentatives ‚Ä¢ <b>${HINT_MAX}</b> indices (1 par question).`;
      optionsEl.innerHTML="";
      hudQnum.textContent="1";
      hudTime.textContent=String(TIMER_SECONDS);
      ring.style.setProperty("--p","100%");
      setRingProgress();

      setScore(score);
      setStress(stress);
      setAttemptsUI();
      setHints(hintsLeft);
      setProgress();

      showKeyBtn.disabled = true;
      endBtn.style.display = "none";
      validateBtn.disabled = true;
    })();
  </script>
<script src="badge-manager.js"></script>
  <!-- (optionnel) si tu utilises ton gestionnaire de badges -->
  <!-- <script src="badge-manager.js"></script> -->
</body>
</html>
